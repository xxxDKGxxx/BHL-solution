question,answer
Czym jest rekurencja?,"('**Rekurencja** (ang. recursion) to technika programistyczna, w której funkcja lub procedura odwołuje się do samej siebie, bezpośrednio lub pośrednio, w celu rozwiązania problemu poprzez rozbicie go na prostsze podproblemy.\n\nAby rekurencja była poprawna i gwarantowała zakończenie działania, musi zawierać dwa kluczowe elementy:\n\n1.  **Warunek bazowy (Base Case):** Stan, dla którego funkcja zwraca wynik bezpośrednio, bez dalszych wywołań rekurencyjnych. Jest to mechanizm kończący.\n2.  **Krok rekurencyjny (Recursive Step):** Wywołanie tej samej funkcji z danymi wejściowymi zmienionymi w taki sposób, aby zbliżyć się do warunku bazowego.\n\n### Zastosowanie i Przykład\n\n**Przykład:** Obliczanie **silni** ($n!$) w informatyce.\n\nDefinicja rekurencyjna: $n! = n \\cdot (n-1)!$\n\n*   **Warunek bazowy:** Jeśli $n = 0$, to $0! = 1$.\n*   **Krok rekurencyjny:** Jeśli $n > 0$, funkcja oblicza $n$ razy wynik wywołania samej siebie dla wartości $n-1$.\n\n**Dodatkowe konteksty:**\n\nChociaż rekurencja często prowadzi do bardziej eleganckiego i czytelnego kodu (np. przy **przeszukiwaniu drzew** i struktur danych), jej nieprawidłowe użycie lub brak warunku bazowego skutkuje nieskończoną pętlą wywołań, co prowadzi do **przepełnienia stosu** (Stack Overflow) i błędu pamięci. Każdy algorytm rekurencyjny może zostać przepisany w formie iteracyjnej.', False, 'None')"
Jak działa Garbage Collector w Javie?,"('**Garbage Collector (GC) w Javie** to automatyczny mechanizm zarządzania pamięcią, który zwalnia programistę z ręcznego przydzielania i zwalniania pamięci.\n\n### Cel i Działanie\n\nPodstawowym celem GC jest automatyczne znajdowanie i usuwanie z **pamięci sterty (Heap)** obiektów, do których aplikacja nie ma już żadnych odniesień (czyli obiektów **nieosiągalnych**), tym samym zapobiegając wyciekom pamięci.\n\nGC działa, opierając się na założeniu hipotezy generacyjnej, dzieląc stertę na **Młodą Generację** (gdzie obiekty są szybko tworzone i niszczone) oraz **Starą Generację**.\n\n### Podstawowe Fazy Procesu\n\nProces odzyskiwania pamięci zazwyczaj odbywa się w trzech głównych fazach:\n\n1.  **Mark (Oznaczanie):** GC identyfikuje wszystkie obiekty osiągalne (żywe), śledząc odniesienia wychodzące ze zbioru korzeni (np. wątki, zmienne statyczne). Obiekty, które nie zostały oznaczone, są uznawane za ""śmieci"".\n2.  **Sweep (Usuwanie):** Usuwanie nieosiągalnych obiektów i zwalnianie zajmowanej przez nie przestrzeni w pamięci.\n3.  **Compact (Kompaktowanie):** Opcjonalne (choć często konieczne) przesunięcie żywych obiektów, aby wypełnić luki pozostawione przez usunięte obiekty. Zapobiega to **fragmentacji pamięci**, która mogłaby utrudnić alokację dużych, ciągłych bloków w przyszłości.\n\n### Popularne Typy Kolektorów w JVM\n\nWspółczesne maszyny wirtualne Javy (JVM) oferują kilka typów kolektorów, optymalizowanych pod kątem przepustowości (throughput) lub minimalizacji czasów pauzy:\n\n1.  **Serial GC:** Najprostszy, działa na jednym wątku. Wymaga **Stop-the-World (STW)**, podczas którego wszystkie wątki aplikacji są zatrzymywane. Dedykowany małym aplikacjom.\n2.  **Parallel GC:** Kolektor skupiający się na przepustowości. Wykorzystuje wiele wątków do wykonywania pracy GC, ale nadal wymaga długich pauz STW.\n3.  **G1 (Garbage First):** Obecnie domyślny kolektor w Javie. Dzieli stertę na regiony i dąży do osiągnięcia przewidywalnych, krótkich czasów pauzy, wybierając do czyszczenia te regiony, które zawierają najwięcej ""śmieci"".\n4.  **ZGC / Shenandoah:** Nowoczesne kolektory o bardzo niskiej latencji, zaprojektowane do pracy z ogromnymi stertami (terabajty) przy minimalnych pauzach (poniżej 10 ms).\n\n**Fakt uzupełniający:** Czasami działanie GC wymaga zatrzymania wszystkich wątków aplikacji (pauzy STW), jednak nowoczesne kolektory (G1, ZGC) wykonują większość pracy **równolegle** lub **współbieżnie** z działającą aplikacją, minimalizując wpływ na użytkownika.', False, 'None')"
Co to jest REST API?,"(""**REST API (Representational State Transfer Application Programming Interface)** to architektoniczny styl projektowania interfejsów programowania aplikacji, oparty na protokole HTTP. Umożliwia komunikację między systemami rozproszonymi, traktując zasoby (resource) jako kluczowe abstrakcje, do których dostęp uzyskuje się za pomocą standardowych metod HTTP.\n\n### Fundamentalne Zasady i Ograniczenia Architektury REST (Ograniczenia Roy'a Fieldinga)\n\nArchitektura REST powinna spełniać sześć kluczowych ograniczeń:\n\n1.  **Bezstanowość (Statelessness):** Każde żądanie od klienta do serwera musi zawierać wszystkie informacje niezbędne do jego przetworzenia. Serwer nie przechowuje stanu sesji klienta między żądaniami.\n2.  **Klient-Serwer (Client-Server):** Oddzielenie problemów klienta od serwera, co zwiększa przenośność i skalowalność.\n3.  **Możliwość buforowania (Cacheable):** Odpowiedzi na żądania muszą być jawnie oznaczone jako buforowalne lub niebuforowalne, aby poprawić wydajność.\n4.  **Jednolity Interfejs (Uniform Interface):** Najważniejsze ograniczenie, które upraszcza architekturę poprzez:\n    *   Identyfikację zasobów (URI).\n    *   Manipulację zasobami poprzez reprezentacje.\n    *   Wiadomości opisujące same siebie.\n    *   HATEOAS (Hypermedia As The Engine Of Application State – opcjonalne).\n5.  **System warstwowy (Layered System):** Klient nie musi wiedzieć, czy komunikuje się bezpośrednio z serwerem końcowym, czy z pośrednikiem (np. load balancerem, serwerem proxy).\n6.  **Kod na żądanie (Code on Demand):** Opcjonalne; pozwala serwerowi rozszerzać funkcjonalność klienta poprzez przesyłanie kodu wykonywalnego (np. apletów).\n\n### Typowe Metody HTTP (Czasowniki)\n\nInterakcja z zasobami odbywa się za pomocą standardowych metod HTTP, które odpowiadają operacjom CRUD (Create, Read, Update, Delete):\n\n*   **GET:** Pobieranie reprezentacji zasobu (Read). Powinno być idempotentne i bezpieczne.\n*   **POST:** Tworzenie nowego zasobu lub przesłanie danych, które mogą zmieniać stan serwera (Create).\n*   **PUT:** Aktualizacja istniejącego zasobu lub całkowite zastąpienie zasobu pod określonym URI (Update). Idempotentne.\n*   **DELETE:** Usuwanie zasobu (Delete). Idempotentne.\n*   **PATCH:** Częściowa aktualizacja zasobu (Update).\n\n### Formaty Wymiany Danych\n\nDane w REST API są najczęściej wymieniane w formatach lekkich i czytelnych dla człowieka:\n\n*   **JSON (JavaScript Object Notation):** Zdecydowanie dominujący standard.\n*   **XML (Extensible Markup Language):** Nadal stosowany w starszych systemach lub specyficznych branżach.\n\n**Fakt uzupełniający:** Prawdziwe API, które spełnia wszystkie ograniczenia REST, nazywane jest **RESTful**. Kluczową różnicą między REST a starszymi rozwiązaniami (np. SOAP) jest to, że REST wykorzystuje w pełni możliwości protokołu HTTP (np. metody, kody statusu i nagłówki), zamiast traktować go jako prosty tunel transportowy."", False, 'None')"
Jaka jest różnica między listą a krotką w Pythonie?,"('Poniżej przedstawiono kluczowe różnice między listą (list) a krotką (tuple) w języku Python, które są dwoma podstawowymi sekwencyjnymi typami danych.\n\n| Cecha | Lista (list) | Krotka (tuple) |\n| :--- | :--- | :--- |\n| **Deklaracja** | Używa nawiasów kwadratowych: `[1, 2, \'a\']` | Używa nawiasów okrągłych: `(1, 2, \'a\')` |\n| **Mutowalność** | **Mutowalna** (Mutable) – jej elementy mogą być zmieniane, dodawane lub usuwane po utworzeniu. | **Niemutowalna** (Immutable) – raz utworzona, jej zawartość nie może być modyfikowana. |\n| **Przeznaczenie** | Kolekcje elementów, które muszą być dynamicznie modyfikowane. | Dane, które nie powinny być zmieniane (np. stałe, współrzędne). |\n\n### Kluczowe Atrybuty i Różnice\n\n1.  **Mutowalność:** To najważniejsza różnica. Listy pozwalają na operacje takie jak `append()`, `insert()`, czy `pop()`, natomiast próba zmiany elementu krotki zakończy się błędem `TypeError`.\n2.  **Wydajność:** Krotki są zazwyczaj nieco szybsze w dostępie i iteracji niż listy, ponieważ struktura niemutowalna jest mniej obciążona operacjami w tle.\n3.  **Zużycie Pamięci:** Krotki zużywają mniej pamięci niż listy.\n4.  **Użycie jako Klucze Słowników:** Ponieważ krotki są niemutowalne, mogą być używane jako klucze w słownikach (dictionary keys), co jest niemożliwe w przypadku list.\n\n### Przykłady Zastosowań\n\n**Lista:**\nIdealna, gdy potrzebujemy dynamicznej kolekcji.\n*   Zbieranie danych wejściowych od użytkownika.\n*   Implementacja stosów i kolejek.\n*   Przykładowy kod:\n    ```python\n    dane_miesieczne = [100, 150, 200]\n    dane_miesieczne.append(250) # Możliwa modyfikacja\n    ```\n\n**Krotka:**\nIdealna do przechowywania stałych zestawów danych lub jako wynik funkcji.\n*   Przechowywanie **współrzędnych geograficznych** (`(lat, lon)`).\n*   Reprezentowanie rekordów bazy danych, które nie powinny być zmieniane.\n*   Zwracanie wielu wartości z pojedynczej funkcji.\n*   Przykładowy kod:\n    ```python\n    wspolrzedne = (52.2297, 21.0122)\n    # wspolrzedne[0] = 53.0 # Spowoduje błąd\n    ```\n\n**Fakt uzupełniający:** Niemutowalność krotki oznacza, że są one ""bezpieczne"" w kontekście współbieżności i są często preferowane w sytuacjach, gdy integralność danych jest krytyczna. Nawiasy okrągłe w krotce nie są ściśle wymagane do jej utworzenia; liczy się przecinek (np. `a = 1, 2, 3` tworzy krotkę).', False, 'None')"
Do czego służy polecenie git commit?,"('**Polecenie `git commit`** służy do trwałego zapisania (utrwalenia) bieżącego stanu plików, które zostały wcześniej dodane do **poczekalni (staging area)**, tworząc migawkę (snapshot) projektu w systemie kontroli wersji Git.\n\n### Cel i Działanie\n\nGłównym celem `git commit` jest formalne zakończenie pewnego logicznego bloku pracy. Commit tworzy punkt historii, do którego można wrócić w przyszłości, co umożliwia śledzenie zmian, cofanie błędów oraz zarządzanie rozwojem projektu.\n\n**Cykl pracy:**\n\n1.  Modyfikacja plików.\n2.  Dodanie wybranych zmian do poczekalni (`git add`).\n3.  Zapisanie stanu poczekalni jako nowej rewizji za pomocą `git commit`.\n\n### Wiadomość Commit (Commit Message)\n\nKluczowym elementem `git commit` jest **wiadomość commit** (`-m ""opis zmian""`). Jest to opis, który wyjaśnia, co zostało zmienione, dlaczego i jaki problem rozwiązano. Dobrze napisane wiadomości są niezbędne do efektywnego przeglądu historii projektu i współpracy zespołowej.\n\n### Miejsce Docelowe Zmian\n\nPo wykonaniu `git commit`, zmiany trafiają do lokalnej **bazy danych Git (repository)**, tworząc nowy, niezmienialny obiekt commit. Ten nowy commit staje się **wierzchołkiem (HEAD)** bieżącej gałęzi.\n\nZmiany te są zapisane **wyłącznie w lokalnym repozytorium** użytkownika. Aby udostępnić je innym współpracownikom lub przesłać na serwer zdalny (np. GitHub, GitLab), konieczne jest użycie dodatkowego polecenia, np. `git push`.\n\n**Fakt uzupełniający:** Każdy commit jest identyfikowany przez unikalny, 40-znakowy **hash SHA-1**. Hash ten jest generowany na podstawie zawartości commita (drzewa plików, autora, czasu oraz referencji do poprzedniego commita), co gwarantuje integralność danych i uniemożliwia niezauważoną modyfikację historii.', False, 'None')"
Czym jest SQL Injection?,"('**SQL Injection (SQLi)** to jeden z najpowszechniejszych i najgroźniejszych typów ataków cybernetycznych, polegający na wstrzyknięciu złośliwego kodu SQL do zapytania bazodanowego poprzez niezabezpieczone dane wejściowe dostarczane przez użytkownika.\n\n### Mechanizm Działania i Cel\n\n**Mechanizm:** Atak ma miejsce, gdy aplikacja tworzy zapytanie SQL dynamicznie, łącząc je ze sobą za pomocą surowych (nieoczyszczonych i niezweryfikowanych) danych pochodzących bezpośrednio od użytkownika (np. z pól formularzy logowania czy parametrów URL). Wstrzyknięty fragment kodu zmienia pierwotną logikę zapytania.\n\n**Cel:** Głównym celem atakującego jest obejście mechanizmów uwierzytelniania, odczytanie, modyfikacja lub usunięcie poufnych danych z bazy danych, a w skrajnych przypadkach przejęcie kontroli nad systemem bazodanowym.\n\n### Najczęściej Atakowane Elementy\n\nSQL Injection najczęściej celuje w następujące elementy aplikacji:\n\n1.  **Pola Logowania:** Umożliwia pominięcie weryfikacji hasła (np. przez wstrzyknięcie klauzuli `OR 1=1`).\n2.  **Pola Wyszukiwania:** Pozwala na ekstrakcję informacji z całej bazy, zamiast ograniczenia wyników do autoryzowanego zakresu.\n3.  **Parametry URL:** Dane przesyłane przez metodę GET, które są wykorzystywane do budowania zapytań.\n\n### Kluczowe Metody Zabezpieczające\n\nNajbardziej skutecznymi i zalecanymi metodami ochrony przed SQLi są:\n\n1.  **Parametryzowane Zapytania (Prepared Statements):** Jest to podstawowa obrona. Zapytanie jest predefiniowane, a dane wejściowe użytkownika są traktowane wyłącznie jako wartości (literals), a nie jako część kodu SQL.\n2.  **Walidacja Danych Wejściowych:** Użycie list dozwolonych wartości (whitelisting) oraz ścisła weryfikacja typów danych (np. upewnienie się, że pole `id` jest liczbą całkowitą, a nie ciągiem znaków).\n3.  **Zasada Najmniejszych Uprawnień (Principle of Least Privilege):** Konta użytkowników baz danych, z których korzysta aplikacja, powinny mieć uprawnienia tylko do tych tabel i operacji, które są absolutnie niezbędne do ich funkcjonowania (np. brak uprawnień administracyjnych).\n\n**Fakt uzupełniający:** SQL Injection jest klasyfikowany przez OWASP (Open Web Application Security Project) jako jeden z krytycznych błędów bezpieczeństwa (obecnie pod nazwą Injection w rankingu OWASP Top 10).', False, 'None')"
Co oznacza akronim SOLID?,"('Akronim **SOLID** odnosi się do pięciu fundamentalnych zasad programowania obiektowego i projektowania oprogramowania. Zostały one skodyfikowane przez Roberta C. Martina (znanego jako ""Uncle Bob"") i służą do tworzenia systemów łatwiejszych do utrzymania, rozszerzania i testowania.\n\n### Pełne Nazwy i Opis Zasad SOLID\n\n| Litera | Pełna Nazwa Zasady | Opis Zasady |\n| :--- | :--- | :--- |\n| **S** | **Single Responsibility Principle (SRP)** | Zasada pojedynczej odpowiedzialności: Klasa powinna mieć tylko jeden powód do zmiany, co oznacza, że powinna zajmować się tylko jedną odpowiedzialnością lub zadaniem. |\n| **O** | **Open/Closed Principle (OCP)** | Zasada otwarte/zamknięte: Klasy, moduły lub funkcje powinny być otwarte na rozszerzenia, ale zamknięte na modyfikacje. |\n| **L** | **Liskov Substitution Principle (LSP)** | Zasada podstawiania Liskov: Obiekty w programie powinny być zastępowalne przez instancje ich podtypów bez zmiany poprawności działania programu (czyli podklasy muszą zachowywać się jak ich klasy bazowe). |\n| **I** | **Interface Segregation Principle (ISP)** | Zasada segregacji interfejsów: Klienci nie powinni być zmuszani do implementowania interfejsów, których nie używają. Lepiej mieć wiele małych, specyficznych interfejsów niż jeden duży, ogólny. |\n| **D** | **Dependency Inversion Principle (DIP)** | Zasada odwrócenia zależności: Moduły wysokiego poziomu nie powinny zależeć od modułów niskiego poziomu. Oba powinny zależeć od abstrakcji (interfejsów). Abstrakcje nie powinny zależeć od szczegółów, szczegóły powinny zależeć od abstrakcji. |\n\n### Dlaczego Zasady SOLID Są Fundamentalne\n\nZasady te są fundamentalne w inżynierii oprogramowania, ponieważ ich stosowanie prowadzi do:\n\n*   **Zmniejszenia złożoności:** Poprzez rozbijanie dużych klas na mniejsze, odpowiedzialne moduły (SRP, ISP).\n*   **Większej elastyczności:** Systemy stają się łatwiejsze do rozszerzania nowymi funkcjami bez konieczności modyfikowania istniejącego, działającego kodu (OCP).\n*   **Lepszej testowalności:** Mniejsze, odizolowane komponenty są łatwiejsze do testowania jednostkowego.\n*   **Redukcji zależności:** Odwrócenie zależności (DIP) prowadzi do bardziej luźno sprzężonych (loosely coupled) systemów, które są bardziej odporne na zmiany.\n\n**Fakt uzupełniający:** Chociaż Robert C. Martin spopularyzował ten akronim, same zasady (zwłaszcza Liskov Substitution Principle) zostały pierwotnie sformułowane przez inne osoby (np. Barbara Liskov). Zasady te są szczególnie ważne w kontekście języków obiektowych, takich jak Java, C# i Python.', False, 'None')"
Czym jest Docker?,"('**Docker** to wiodąca platforma do rozwijania, wdrażania i uruchamiania aplikacji za pomocą **kontenerów** (containers). Umożliwia pakowanie aplikacji i wszystkich jej zależności (bibliotek, konfiguracji, binariów) w jeden izolowany pakiet.\n\n### Podstawowa Funkcja\n\nPodstawową funkcją Dockera jest zapewnienie, że aplikacja będzie działać w ten sam sposób, niezależnie od środowiska, w którym zostanie uruchomiona (np. na komputerze dewelopera, na serwerze testowym czy produkcyjnym). Osiąga to poprzez izolację procesu aplikacji od systemu hosta.\n\n### Kontener a Maszyna Wirtualna (VM)\n\nGłówna różnica polega na warstwie wirtualizacji:\n\n| Cecha | Kontener (Docker) | Maszyna Wirtualna (VM) |\n| :--- | :--- | :--- |\n| **Izolacja** | Wirtualizacja na poziomie systemu operacyjnego. | Wirtualizacja sprzętu (pełna emulacja). |\n| **Wymagania SO** | Wszystkie kontenery współdzielą jądro (kernel) systemu operacyjnego hosta. | Każda VM musi zawierać własny, kompletny, gościnny system operacyjny. |\n| **Rozmiar** | Bardzo małe (megabajty), szybkie uruchamianie (sekundy lub milisekundy). | Duże (gigabajty), wolniejsze uruchamianie (minuty). |\n| **Overhead** | Niski narzut systemowy. | Duży narzut, wymaga więcej pamięci i mocy CPU. |\n\n### Kluczowe Korzyści w Procesie Tworzenia i Wdrażania\n\nDocker rewolucjonizuje procesy CI/CD (Continuous Integration/Continuous Deployment) dzięki następującym korzyściom:\n\n1.  **Powtarzalność (Reproducibility):** Gwarantuje, że środowisko uruchomieniowe (np. wersja Pythona, biblioteki) jest zawsze identyczne – znika problem ""U mnie działa!"".\n2.  **Szybkie Wdrażanie:** Kontenery uruchamiają się niemal natychmiast, co przyspiesza proces wdrażania i skalowania aplikacji.\n3.  **Izolacja Środowiska:** Umożliwia uruchomienie wielu różnych aplikacji i ich wersji na tym samym serwerze bez wzajemnego zakłócania się.\n4.  **Uproszczenie CI/CD:** Konteneryzacja jest podstawą nowoczesnej architektury mikroserwisów i zarządzania nimi za pomocą narzędzi takich jak **Kubernetes**.\n\n**Fakt uzupełniający:** Docker do działania wykorzystuje funkcje wbudowane w jądro Linuksa, takie jak **cgroups** (do limitowania zasobów) i **namespaces** (do izolacji procesów). ""Obraz Dockerowy"" (Docker Image) jest szablonem, który staje się kontenerem po uruchomieniu.', False, 'None')"
Co to jest złożoność obliczeniowa Big O?,"('**Złożoność obliczeniowa Big O (asymptotyczne tempo wzrostu)** to matematyczny zapis używany w informatyce do opisu wydajności algorytmu. Mierzy, jak czas wykonania (lub zużycie pamięci) algorytmu rośnie w zależności od wzrostu rozmiaru danych wejściowych ($n$). Złożoność Big O koncentruje się na najgorszym przypadku, ignorując stałe współczynniki i człony niższego rzędu.\n\n### Podstawowy Cel\n\nPodstawowym celem złożoności Big O jest umożliwienie deweloperom i analitykom porównania i oceny efektywności algorytmów w sposób niezależny od konkretnego sprzętu, języka programowania czy szybkości procesora. Big O pozwala przewidzieć skalowalność algorytmu w miarę wzrostu zbioru danych.\n\n### Trzy Najczęściej Spotykane Przypadki\n\nPodczas analizy algorytmu zazwyczaj rozpatruje się trzy przypadki, określające, jak algorytm zachowa się w różnych scenariuszach wejściowych:\n\n1.  **Najgorszy przypadek (Worst Case):** Oznaczany jako $O(f(n))$. Opisuje maksymalny czas wykonywania, jaki może zająć algorytm dla dowolnego wejścia o rozmiarze $n$. Jest to najczęściej używana metryka.\n2.  **Najlepszy przypadek (Best Case):** Oznaczany jako $\\Omega(f(n))$. Opisuje minimalny czas wykonywania.\n3.  **Przypadek przeciętny (Average Case):** Oznaczany jako $\\Theta(f(n))$. Opisuje oczekiwany czas wykonywania dla losowego wejścia. Jest to trudniejszy do obliczenia, ale bardziej realistyczny wskaźnik.\n\n### Najpopularniejsze Notacje Złożoności\n\nOto najczęściej spotykane notacje złożoności, uporządkowane od najbardziej do najmniej wydajnych:\n\n| Notacja | Nazwa | Charakterystyka | Przykład |\n| :--- | :--- | :--- | :--- |\n| $O(1)$ | Stała | Czas wykonania nie zależy od rozmiaru danych wejściowych $n$. | Dostęp do elementu w tablicy po indeksie. |\n| $O(\\log n)$ | Logarytmiczna | Czas rośnie wolno (częste przy podziale problemu na pół). | Wyszukiwanie binarne. |\n| $O(n)$ | Liniowa | Czas wykonania jest wprost proporcjonalny do rozmiaru $n$. | Przejście przez wszystkie elementy listy. |\n| $O(n \\log n)$ | Liniowo-logarytmiczna | Bardzo wydajne sortowanie. | Sortowanie przez scalanie (Merge Sort). |\n| $O(n^2)$ | Kwadratowa | Czas rośnie kwadratowo (dla dużych $n$ staje się nieefektywny). | Proste algorytmy sortowania (np. bąbelkowe). |\n| $O(2^n)$ | Wykładnicza | Bardzo wolna; stosowana w problemach NP-trudnych. | Brute force (np. Problem Komiwojażera). |\n\n**Fakt uzupełniający:** Chociaż Big O opisuje czas (lub miejsce) w najgorszym przypadku, często stosuje się ją również jako ogólny wskaźnik skalowalności. Im wolniejsze tempo wzrostu $f(n)$, tym algorytm jest bardziej skalowalny dla dużych zbiorów danych.', False, 'None')"
Na czym polega dziedziczenie w OOP?,"('**Dziedziczenie (Inheritance)** to jeden z kluczowych mechanizmów programowania obiektowego (OOP), który pozwala nowo tworzonym klasom (podklasom) przejąć atrybuty i metody istniejącej klasy (klasy bazowej/nadrzędnej).\n\n### Cel Dziedziczenia\n\nGłównym celem dziedziczenia jest:\n\n1.  **Reużywalność Kodu (Code Reusability):** Pozwala uniknąć powielania kodu, ponieważ wspólna funkcjonalność jest umieszczona w klasie bazowej i automatycznie dostępna dla wszystkich klas potomnych.\n2.  **Ustanowienie Relacji ""Jest-A"" (Is-A Relationship):** Modeluje hierarchię relacji logicznych w świecie rzeczywistym (np. ""Pies **jest** Zwierzęciem"").\n3.  **Polimorfizm:** Umożliwia implementację polimorfizmu, gdzie podklasa może nadpisywać (override) metody klasy bazowej, dostosowując ich działanie.\n\n### Relacja Między Klasami\n\nW dziedziczeniu wyróżnia się dwie główne role:\n\n*   **Klasa Bazowa / Klasa Nadrzędna / Superklasa (Base Class / Parent Class):** Klasa, która udostępnia swoje cechy.\n*   **Podklasa / Klasa Pochodna (Subclass / Derived Class):** Klasa, która przejmuje (dziedziczy) cechy klasy bazowej. Podklasa może dodawać własne unikatowe funkcje lub redefiniować (nadpisywać) funkcje odziedziczone.\n\n### Główne Typy Dziedziczenia\n\nW zależności od języka programowania, implementacja dziedziczenia może się różnić:\n\n1.  **Dziedziczenie Pojedyncze (Single Inheritance):** Podklasa dziedziczy cechy tylko po jednej klasie bazowej (np. Java, C#). Jest to najprostszy i najbezpieczniejszy typ.\n2.  **Dziedziczenie Wielokrotne (Multiple Inheritance):** Podklasa dziedziczy cechy z więcej niż jednej klasy bazowej (np. C++, Python). Choć potężne, może prowadzić do problemów takich jak **""Problem Diamentu""** (Diamond Problem), gdy klasa dziedziczy tę samą metodę z wielu źródeł, powodując niejednoznaczność.\n3.  **Dziedziczenie Wielopoziomowe (Multilevel Inheritance):** Klasa dziedziczy po innej podklasie (A dziedziczy po B, a B dziedziczy po C).\n\n**Fakt uzupełniający:** W wielu językach, które nie wspierają bezpośrednio dziedziczenia wielokrotnego (jak Java i C#), koncepcja ta jest zastąpiona przez możliwość implementacji wielu **interfejsów**, co zapewnia reużywalność specyfikacji zachowania bez przejmowania implementacji kodu, minimalizując ryzyko wspomnianego Problemu Diamentu.', False, 'None')"
Czym są Promises w JavaScript?,"('**Promises (Obietnice)** w języku JavaScript to obiekty, które reprezentują ostateczne zakończenie (lub niepowodzenie) operacji asynchronicznej. Promises stanowią standardowy sposób zarządzania kodem asynchronicznym, zastępując starsze, mniej czytelne wzorce, takie jak zagnieżdżone wywołania zwrotne (**callback hell**).\n\n### Cel Wprowadzenia\n\nGłównym celem wprowadzenia Promises było ustrukturyzowanie i uproszczenie obsługi operacji asynchronicznych (np. pobierania danych z API, operacji na plikach, timeoutów). Pozwalają one na łańcuchowe łączenie operacji asynchronicznych w sposób sekwencyjny i bardziej czytelny.\n\n### Kluczowe Stany Obietnicy\n\nObietnica zawsze znajduje się w jednym z trzech wzajemnie wykluczających się stanów:\n\n1.  **Oczekujący (Pending):** Początkowy stan – ani zakończony pomyślnie, ani odrzucony. Operacja asynchroniczna jest w toku.\n2.  **Spełniony (Fulfilled/Resolved):** Operacja asynchroniczna zakończyła się sukcesem, a Obietnica ma teraz wartość wynikową.\n3.  **Odrzucony (Rejected):** Operacja asynchroniczna zakończyła się błędem, a Obietnica ma teraz powód (obiekt błędu).\n\nObietnica jest pewnym mechanizmem **jednorazowym** – raz przechodząc w stan *Spełniony* lub *Odrzucony* (czyli stan **Rozstrzygnięty/Settled**), nie może już zmienić swojego stanu.\n\n### Metody Obsługi Rezultatu\n\nDo obsługi wyników Obietnicy używa się następujących metod łańcuchowych:\n\n*   **`.then(onFulfilled, onRejected)`:** Metoda używana do obsługi pomyślnego zakończenia (`onFulfilled`) lub opcjonalnie do obsługi błędu. Zwraca nową Obietnicę, co umożliwia tworzenie **łańcuchów obietnic** (Promise Chaining).\n*   **`.catch(onRejected)`:** Jest to skrócona forma `.then(null, onRejected)`, używana głównie do obsługi błędów w łańcuchu Obietnic.\n*   **`.finally(onFinally)`:** Wykonywana po rozstrzygnięciu Obietnicy (z sukcesem lub błędem), używana do czyszczenia zasobów.\n\n**Fakt uzupełniający:** Wprowadzenie Obietnic umożliwiło rozwój składni **`async/await`** (wprowadzonej w ECMAScript 2017), która działa jako syntaktyczny cukier na Promises. Składnia `async/await` pozwala pisać kod asynchroniczny w sposób, który wygląda i działa jak kod synchroniczny, dodatkowo poprawiając jego czytelność.', False, 'None')"
Co to jest klucz główny (Primary Key)?,"('**Klucz główny (Primary Key)** to atrybut (kolumna) lub zbiór atrybutów w tabeli relacyjnej bazy danych, który **jednoznacznie identyfikuje** każdy wiersz (rekord) w tej tabeli.\n\n### Rola w Tabeli\n\nKlucz główny pełni rolę fundamentalnego identyfikatora. Służy do:\n\n1.  **Unikalnej Identyfikacji:** Gwarantuje, że nie ma dwóch identycznych rekordów w tabeli.\n2.  **Organizacji Danych:** Służy jako podstawowy punkt dostępu do rekordów, często wykorzystywany przez indeksy bazodanowe, aby przyspieszyć operacje wyszukiwania i pobierania danych.\n3.  **Tworzenia Relacji:** Stanowi referencyjny punkt dla innych tabel w bazie danych.\n\n### Kluczowe Wymagania\n\nKlucz główny musi spełniać dwa rygorystyczne wymagania, co jest egzekwowane przez system zarządzania bazą danych (DBMS):\n\n1.  **Unikalność (Uniqueness):** Wartość klucza głównego musi być unikalna dla każdego wiersza w tabeli.\n2.  **Integralność Encji (Entity Integrity / NOT NULL):** Żadna część klucza głównego nie może przyjmować wartości pustej (NULL).\n\n### Połączenie z Kluczem Obcym (Foreign Key)\n\nKlucz główny jest ściśle związany z koncepcją klucza obcego:\n\n*   **Klucz obcy (Foreign Key)** jest kolumną w jednej tabeli, która **referuje** (wskazuje) na klucz główny innej tabeli.\n*   Klucz obcy służy do ustanawiania i egzekwowania **relacji** między dwiema tabelami (np. relacji jeden-do-wielu, gdzie tabela zamówień referuje do klucza głównego tabeli klientów).\n*   Relacja ta zapewnia **integralność referencyjną**, uniemożliwiając na przykład usunięcie klienta, jeśli istnieją powiązane z nim zamówienia.\n\n**Fakt uzupełniający:** Klucze główne mogą być naturalne (np. numer PESEL) lub zastępcze/sztuczne (**surrogate keys**). W nowoczesnych systemach najczęściej stosuje się te drugie (np. automatycznie inkrementowane liczby całkowite lub UUID), ponieważ są one stabilne i nie zmieniają się, co jest kluczowe dla integralności referencyjnej.', False, 'None')"
Czym jest framework React?,"('**React** (często nazywany React.js lub ReactJS) jest deklaratywną, efektywną i elastyczną **biblioteką JavaScriptową** (nie pełnym frameworkiem, choć często tak opisywany) służącą do budowania interfejsów użytkownika (UI). Został stworzony i jest utrzymywany przez firmę Meta (dawniej Facebook).\n\n### Podstawowa Funkcja i Cel\n\nPodstawową funkcją Reacta jest zarządzanie stanem i renderowanie widoku w aplikacjach internetowych.\n\n**Cel:** Ułatwienie tworzenia dużych aplikacji, których dane zmieniają się w czasie. React opiera się na idei, że deweloperzy deklarują, jak ma wyglądać UI w danym stanie, a biblioteka sama dba o efektywną aktualizację DOM, gdy stan ulegnie zmianie.\n\n### Kluczowe Koncepcje\n\n1.  **Komponenty (Components):** Są to podstawowe bloki konstrukcyjne Reacta. Komponenty to niezależne, wielokrotnego użytku fragmenty kodu, które zwracają elementy Reacta opisujące, co ma być wyświetlone. Mogą to być funkcje (Function Components) lub klasy (Class Components).\n2.  **Virtual DOM (VDOM):** To lekka, abstrakcyjna kopia faktycznego, przeglądarkowego modelu DOM. Zamiast bezpośrednio manipulować wolnym DOM przeglądarki, React najpierw porównuje zmiany w VDOM. Następnie oblicza optymalny sposób aktualizacji tylko tych elementów prawdziwego DOM, które faktycznie się zmieniły, co drastycznie zwiększa wydajność.\n3.  **State and Props:** *State* (Stan) to prywatne dane zarządzane wewnątrz komponentu. *Props* (Właściwości) to dane przekazywane z komponentu nadrzędnego do komponentu potomnego.\n\n### Architektura Aplikacyjna\n\nReact jest najczęściej stosowany w architekturze **SPA (Single Page Application)**, gdzie cała aplikacja jest ładowana na jednej stronie HTML, a widok jest dynamicznie zmieniany za pomocą JavaScript.\n\n**Fakt uzupełniający:** Dzięki zastosowaniu komponentów i Virtual DOM, React z powodzeniem jest wykorzystywany nie tylko do tworzenia interfejsów przeglądarkowych (za pomocą React DOM), ale także aplikacji mobilnych (poprzez **React Native**) czy nawet aplikacji desktopowych. React promuje styl programowania oparty na **jednokierunkowym przepływie danych** (Unidirectional Data Flow).', False, 'None')"
Co to jest CI/CD?,"('**CI/CD** to zestaw praktyk, które umożliwiają ciągłe dostarczanie (lub wdrażanie) zmian w oprogramowaniu w sposób automatyczny i powtarzalny. Jest to kluczowy element nowoczesnych metodyk DevOps.\n\n### Co Oznaczają Akronimy\n\n| Akronim | Pełna Nazwa | Rola w Cyklu Życia Oprogramowania |\n| :--- | :--- | :--- |\n| **CI** | **Ciągła Integracja (Continuous Integration)** | Proces automatycznego budowania i testowania kodu za każdym razem, gdy deweloperzy wprowadzają zmiany do głównego repozytorium. |\n| **CD** | **Ciągłe Dostarczanie (Continuous Delivery)** lub **Ciągłe Wdrażanie (Continuous Deployment)** | Proces automatyzacji dostarczania zmian do środowiska testowego, stagingowego lub produkcyjnego. |\n\n### Rola Elementów CI i CD\n\n**1. Ciągła Integracja (CI):**\n\n*   **Cel:** Zapewnienie, że kod wszystkich członków zespołu działa poprawnie, gdy jest łączony.\n*   **Proces:** Obejmuje automatyczne uruchamianie testów jednostkowych i integracyjnych, kompilację kodu i tworzenie artefaktów (np. obrazów Dockera, plików wykonywalnych). Wczesne wykrywanie błędów zmniejsza koszty ich naprawy.\n\n**2. Ciągłe Dostarczanie / Wdrażanie (CD):**\n\n*   **Continuous Delivery:** Po pomyślnym przejściu CI, zmiany są automatycznie przygotowywane do wydania. Wdrożenie na środowisko produkcyjne jest wykonywane ręcznie przez człowieka.\n*   **Continuous Deployment:** Zmiany przechodzą całą drogę automatycznie, aż do wdrożenia na środowisko produkcyjne, bez potrzeby interwencji człowieka. Wymaga bardzo wysokiej pewności w testy automatyczne.\n\n### Główne Korzyści Automatyzacji\n\nAutomatyzacja potoku CI/CD znacząco poprawia efektywność pracy zespołu:\n\n*   **Skrócenie Czasu Wydania (Time to Market):** Umożliwia szybsze dostarczanie nowych funkcji i poprawek.\n*   **Zmniejszenie Ryzyka Błędu:** Eliminacja ręcznych, podatnych na pomyłki kroków w procesie budowania i wdrażania.\n*   **Większa Pewność Kodem:** Dzięki stałemu, automatycznemu testowaniu deweloperzy mają większą pewność, że ich zmiany nie złamały istniejącej funkcjonalności.\n*   **Lepsza Współpraca:** Zachęca deweloperów do częstego i małego commitowania zmian.\n\n**Fakt uzupełniający:** Typowe narzędzia wykorzystywane do implementacji potoków CI/CD to **Jenkins, GitLab CI, GitHub Actions** i **CircleCI**. Wdrażanie w środowiskach kontenerowych (Kubernetes) często stanowi końcowy etap automatycznego wdrażania.', False, 'None')"
Czym jest typowanie statyczne?,"('Poniżej przedstawiono kluczowe różnice między listą (list) a krotką (tuple) w języku Python, które są dwoma podstawowymi sekwencyjnymi typami danych.\n\n| Cecha | Lista (list) | Krotka (tuple) |\n| :--- | :--- | :--- |\n| **Deklaracja** | Używa nawiasów kwadratowych: `[1, 2, \'a\']` | Używa nawiasów okrągłych: `(1, 2, \'a\')` |\n| **Mutowalność** | **Mutowalna** (Mutable) – jej elementy mogą być zmieniane, dodawane lub usuwane po utworzeniu. | **Niemutowalna** (Immutable) – raz utworzona, jej zawartość nie może być modyfikowana. |\n| **Przeznaczenie** | Kolekcje elementów, które muszą być dynamicznie modyfikowane. | Dane, które nie powinny być zmieniane (np. stałe, współrzędne). |\n\n### Kluczowe Atrybuty i Różnice\n\n1.  **Mutowalność:** To najważniejsza różnica. Listy pozwalają na operacje takie jak `append()`, `insert()`, czy `pop()`, natomiast próba zmiany elementu krotki zakończy się błędem `TypeError`.\n2.  **Wydajność:** Krotki są zazwyczaj nieco szybsze w dostępie i iteracji niż listy, ponieważ struktura niemutowalna jest mniej obciążona operacjami w tle.\n3.  **Zużycie Pamięci:** Krotki zużywają mniej pamięci niż listy.\n4.  **Użycie jako Klucze Słowników:** Ponieważ krotki są niemutowalne, mogą być używane jako klucze w słownikach (dictionary keys), co jest niemożliwe w przypadku list.\n\n### Przykłady Zastosowań\n\n**Lista:**\nIdealna, gdy potrzebujemy dynamicznej kolekcji.\n*   Zbieranie danych wejściowych od użytkownika.\n*   Implementacja stosów i kolejek.\n*   Przykładowy kod:\n    ```python\n    dane_miesieczne = [100, 150, 200]\n    dane_miesieczne.append(250) # Możliwa modyfikacja\n    ```\n\n**Krotka:**\nIdealna do przechowywania stałych zestawów danych lub jako wynik funkcji.\n*   Przechowywanie **współrzędnych geograficznych** (`(lat, lon)`).\n*   Reprezentowanie rekordów bazy danych, które nie powinny być zmieniane.\n*   Zwracanie wielu wartości z pojedynczej funkcji.\n*   Przykładowy kod:\n    ```python\n    wspolrzedne = (52.2297, 21.0122)\n    # wspolrzedne[0] = 53.0 # Spowoduje błąd\n    ```\n\n**Fakt uzupełniający:** Niemutowalność krotki oznacza, że są one ""bezpieczne"" w kontekście współbieżności i są często preferowane w sytuacjach, gdy integralność danych jest krytyczna. Nawiasy okrągłe w krotce nie są ściśle wymagane do jej utworzenia; liczy się przecinek (np. `a = 1, 2, 3` tworzy krotkę).', True, 'None')"
Co to jest CSS Grid?,"('**CSS Grid Layout (CSS Grid)** to dwuwymiarowy system układu dla CSS, wprowadzony w celu ułatwienia tworzenia złożonych, adaptacyjnych struktur stron internetowych. Umożliwia deweloperom definiowanie wierszy i kolumn, a następnie precyzyjne umieszczanie elementów w określonych komórkach siatki.\n\n### Podstawowa Funkcja i Cel\n\nPodstawową funkcją CSS Grid jest zarządzanie układem **całej strony lub jej dużych sekcji** (np. nagłówka, paska bocznego, głównej treści).\n\n**Cel:** Umożliwienie tworzenia skomplikowanych, siatkowych układów, które są natywnie responsywne (automatycznie dostosowujące się do różnych rozmiarów ekranów) oraz dają pełną kontrolę nad dwuwymiarowym pozycjonowaniem elementów.\n\n### Fundamentalna Różnica w Porównaniu do Flexbox\n\nPodczas gdy Flexbox i Grid są narzędziami do tworzenia układów, różnią się wymiarem i celem:\n\n*   **Flexbox (Flexible Box):** Jest systemem **jednowymiarowym**. Działa świetnie do układania elementów albo wzdłuż wiersza, albo wzdłuż kolumny (ale nie jednocześnie). Idealny do małych komponentów (np. paska nawigacyjnego, grupy kart).\n*   **CSS Grid:** Jest systemem **dwuwymiarowym**. Umożliwia jednoczesne zarządzanie układem wierszy i kolumn, co jest idealne do tworzenia makiet strony (page layout) i złożonych struktur.\n\n### Przykłady Kluczowych Właściwości\n\nDo zdefiniowania i manipulowania strukturą siatki używa się następujących właściwości kontenera (element, do którego zastosowano `display: grid`):\n\n| Właściwość | Funkcja | Przykład |\n| :--- | :--- | :--- |\n| `display: grid;` | Włącza tryb siatki dla kontenera. | |\n| `grid-template-columns` | Definiuje liczbę i rozmiary kolumn. | `1fr 1fr 1fr;` (trzy równe kolumny) |\n| `grid-template-rows` | Definiuje liczbę i rozmiary wierszy. | `auto 200px 50px;` |\n| `grid-gap` | Ustawia odstęp (margines) między komórkami siatki. | `10px 20px;` |\n\nDodatkowo, do pozycjonowania elementów wewnątrz siatki używa się właściwości na elementach potomnych, takich jak `grid-column` i `grid-row`.\n\n**Fakt uzupełniający:** CSS Grid wprowadził nową jednostkę miary **`fr`** (fraction), która reprezentuje dostępną przestrzeń w kontenerze siatki po odjęciu stałych rozmiarów (np. pikseli). Dzięki temu można łatwo tworzyć elastyczne i responsywne kolumny.', False, 'None')"
Wyjaśnij wzorzec Singleton.,"('**Wzorzec projektowy Singleton** jest jednym z **wzorców kreacyjnych**. Gwarantuje, że dla danej klasy może istnieć **tylko jedna instancja** w trakcie działania aplikacji oraz zapewnia globalny punkt dostępu do tej instancji.\n\n### Cel i Mechanizm Działania\n\n**Cel:** Kontrola dostępu do zasobu, który powinien być unikalny dla całego systemu. W ten sposób unika się konfliktów, które mogłyby wyniknąć z istnienia wielu instancji zarządzających tym samym stanem.\n\n**Mechanizm Działania:**\n\n1.  **Prywatny Konstruktor:** Uniemożliwienie utworzenia instancji klasy z zewnątrz za pomocą operatora `new`.\n2.  **Statyczna Zmienna Instancji:** Klasa przechowuje prywatną, statyczną referencję do swojej jedynej instancji.\n3.  **Publiczna Metoda Statyczna (`getInstance()`):** Jest to jedyny punkt dostępu. Metoda ta sprawdza, czy instancja już istnieje; jeśli tak, zwraca ją, w przeciwnym razie tworzy ją, przechowuje, a następnie zwraca.\n\n### Główne Zastosowania\n\nWzorzec Singleton jest używany, gdy zasób musi być centralnie zarządzany:\n\n*   **Zarządzanie Połączeniem z Bazą Danych:** Jedna instancja puli połączeń dla całej aplikacji.\n*   **Loggery:** Jedna instancja systemu logowania do zapisu zdarzeń do pliku.\n*   **Zarządzanie Konfiguracją:** Jedna instancja do wczytywania i przechowywania parametrów konfiguracyjnych.\n\n### Kluczowe Zalety i Wady\n\n| Aspekt | Zalety | Wady |\n| :--- | :--- | :--- |\n| **Kontrola** | Gwarantowana kontrola nad liczbą instancji. | **Testowalność:** Trudny do testowania jednostkowego, ponieważ globalny stan jest trudny do resetowania lub mockowania. |\n| **Dostęp** | Łatwy, globalny dostęp do zasobu. | **Wielowątkowość:** W środowiskach wielowątkowych (multithreading) wymaga specjalnej obsługi synchronizacji (**Thread Safety**), aby uniknąć jednoczesnego utworzenia wielu instancji. |\n| **Architektura** | Usprawnia zarządzanie zasobami. | **Maskowanie zależności:** Wprowadza ukryte zależności w kodzie, co utrudnia refaktoryzację. |\n\n**Fakt uzupełniający:** Ze względu na trudności z testowaniem i ukryte zależności, wzorzec Singleton jest często uznawany za **antywzorzec** w nowoczesnym projektowaniu, zwłaszcza w kontekście Dependency Injection. Lepszą alternatywą może być wstrzykiwanie pojedynczej instancji klasy (scope Singleton) za pomocą kontenera DI.', False, 'None')"
Czym jest funkcja lambda?,"(""**Funkcja lambda (lub wyrażenie lambda)** to mała, anonimowa funkcja, którą można zdefiniować bezpośrednio w miejscu jej użycia. Jest to element programowania funkcyjnego wprowadzony do wielu języków (np. Python, Java, JavaScript, C++) w celu uproszczenia kodu.\n\n### Kluczowe Cechy\n\n1.  **Anonimowość:** Funkcje lambda nie mają formalnej nazwy, co oznacza, że nie są definiowane za pomocą standardowego słowa kluczowego (`def` w Pythonie czy `function` w JavaScript).\n2.  **Zwięzłość:** Są jednowyrażeniowe lub jednowierszowe. Ich składnia jest znacznie krótsza niż standardowej funkcji, ponieważ pomija się nagłówek funkcji i instrukcję `return` (wartość wyrażenia jest zwracana automatycznie).\n3.  **Funkcje Pierwszej Klasy:** Podobnie jak zwykłe funkcje, lambdy mogą być przekazywane jako argumenty do innych funkcji lub zwracane jako wyniki.\n\n### Najczęstsze Zastosowania\n\nGłównym celem funkcji lambda jest redukcja kodu tam, gdzie wymagana jest mała, prosta funkcja, która będzie użyta tylko raz.\n\n*   **Jako Argumenty do Funkcji Wyższego Rzędu:** Lambdy są idealne do przekazywania jako argumenty do funkcji, które jako wejście przyjmują inne funkcje (np. `map`, `filter`, `reduce` w Pythonie/JavaScript).\n*   **Klucze Sortowania:** Definiowanie niestandardowych kluczy w operacjach sortowania (np. `sorted(lista, key=lambda x: x['nazwisko'])`).\n*   **Implementacja Prostych Interfejsów:** W językach takich jak Java 8+, lambdy są używane do implementacji **interfejsów funkcyjnych** (interfejsów z tylko jedną abstrakcyjną metodą).\n\n### Fundamentalne Ograniczenia\n\n1.  **Ograniczona Złożoność:** Lambda może zawierać tylko jedno wyrażenie. Nie można w niej umieszczać wielu instrukcji, pętli czy złożonych warunków (choć można użyć instrukcji warunkowej w formie wyrażenia, np. `a if warunek else b`).\n2.  **Brak Nazwy:** Ponieważ są anonimowe, ich użycie w debugowaniu lub w przypadku bardziej złożonych operacji jest utrudnione.\n\n**Fakt uzupełniający:** W języku Python słowo kluczowe to `lambda` (np. `lambda x: x * 2`). W językach takich jak JavaScript używa się **funkcji strzałkowych** (arrow functions), które są nowoczesnym odpowiednikiem wyrażeń lambda (np. `(x) => x * 2`)."", False, 'None')"
Co to jest JSON?,"('**JSON (JavaScript Object Notation)** to lekki, tekstowy format wymiany danych, zaprojektowany jako podzbiór składni literałów obiektowych języka JavaScript. Jest niezależny od języka programowania, ale używa konwencji, które są znane programistom wielu języków.\n\n### Podstawowa Funkcja i Cel\n\n**Funkcja:** JSON służy do strukturalnego przechowywania i transportowania danych.\n\n**Cel:** Ułatwienie wymiany danych między serwerami a aplikacjami internetowymi (front-end), a także w komunikacji między różnymi usługami i systemami backendowymi. Został stworzony jako bardziej efektywna i prostsza alternatywa dla formatu XML.\n\n### Kluczowe Cechy\n\n1.  **Lekkość:** Minimalistyczna składnia sprawia, że pliki JSON są mniejsze i szybsze do parsowania niż XML.\n2.  **Czytelność dla Człowieka:** Składnia oparta na parze klucz-wartość (jak w słownikach/obiektach) i tablicach jest łatwa do odczytania i napisania.\n3.  **Niezależność od Języka:** Chociaż bazuje na JavaScript, biblioteki do parsowania i generowania JSON są dostępne dla niemal każdego nowoczesnego języka programowania (np. Python, Java, Ruby, C#).\n4.  **Budowa Danych:** JSON wspiera dwa podstawowe typy strukturyzacji danych:\n    *   **Obiekty:** Zbiór par klucz-wartość ujętych w nawiasy klamrowe `{}`.\n    *   **Tablice:** Uporządkowana lista wartości ujęta w nawiasy kwadratowe `[]`.\n\n### Konteksty Technologiczne Wykorzystania\n\nJSON jest obecnie dominującym formatem danych w nowoczesnej informatyce:\n\n1.  **API RESTful:** Jest standardowym formatem przesyłania danych w odpowiedziach i żądaniach do większości nowoczesnych interfejsów API.\n2.  **Konfiguracja:** Stosowany do przechowywania plików konfiguracyjnych dla aplikacji i narzędzi (np. `package.json` w Node.js, konfigi środowiskowe).\n3.  **NoSQL Databases:** Wiele nierelacyjnych baz danych (np. **MongoDB, Couchbase**) przechowuje dane w formacie zbliżonym do JSON (lub Binarnym JSON – BSON).\n\n**Fakt uzupełniający:** JSON obsługuje kilka podstawowych typów danych: ciągi znaków (string), liczby (number), obiekty (object), tablice (array), wartości boolowskie (`true`, `false`) i `null`. Nie obsługuje natywnie typów złożonych, takich jak daty, które muszą być reprezentowane jako ciągi znaków.', False, 'None')"
Czym jest wskaźnik (pointer) w C++?,"('**Wskaźnik (pointer)** w języku C++ to zmienna, która przechowuje **adres pamięci** innej zmiennej. Wskaźniki są kluczowym elementem umożliwiającym bezpośrednią interakcję z pamięcią komputera.\n\n### Definicja i Cel\n\n**Definicja:** Wskaźnik nie przechowuje wartości, a lokalizację w pamięci (adres), pod którą znajduje się rzeczywista dana. Wskaźniki są silnie typowane, co oznacza, że wskaźnik do typu `int` może wskazywać tylko na adres, pod którym przechowywana jest wartość `int`.\n\n**Cel:**\n\n1.  **Dynamiczna Alokacja Pamięci:** Umożliwia rezerwowanie pamięci na stosie (Heap) w czasie wykonania programu za pomocą `new` i zwalnianie jej za pomocą `delete`.\n2.  **Efektywne Przekazywanie Danych:** Pozwala na przekazywanie dużych obiektów do funkcji poprzez ich adres, zamiast kopiowania całej zawartości.\n3.  **Implementacja Struktur Danych:** Są niezbędne do budowania dynamicznych struktur, takich jak listy łączone, drzewa i grafy.\n\n### Sposób Deklaracji i Użycia\n\nWskaźniki wymagają użycia dwóch kluczowych operatorów:\n\n1.  **Operator Adresu (`&` – ampersand):** Zwraca adres pamięci zmiennej.\n    *   Przykład: `int* ptr = &zmienna;`\n2.  **Operator Dereferencji (`*` – gwiazdka):** Używany do:\n    *   **Deklaracji:** Wskazuje, że zmienna jest wskaźnikiem (np. `int* ptr;`).\n    *   **Dostępu (Dereferencji):** Pobiera wartość przechowywaną pod adresem, na który wskazuje wskaźnik (np. `*ptr = 10;` zmienia wartość zmiennej).\n\n### Kluczowe Ryzyka i Zagrożenia\n\nBezpośrednie zarządzanie pamięcią za pomocą surowych wskaźników jest głównym źródłem błędów w C++:\n\n*   **Wycieki Pamięci (Memory Leaks):** Zapomnienie o zwolnieniu pamięci zaalokowanej przez `new` za pomocą `delete`. Pamięć pozostaje niedostępna aż do zakończenia programu.\n*   **Wskaźniki Wiszące (Dangling Pointers):** Wskaźnik, który nadal przechowuje adres pamięci, która została już zwolniona. Próba dereferencji takiego wskaźnika prowadzi do niezdefiniowanego zachowania lub awarii programu.\n*   **Nadpisywanie Pamięci:** Złe obliczenia na wskaźnikach (arytmetyka wskaźników) może prowadzić do modyfikacji danych poza przeznaczonym obszarem.\n\n**Fakt uzupełniający:** Aby zaradzić ryzykom surowych wskaźników, w nowoczesnym C++ (od standardu C++11) zaleca się używanie **inteligentnych wskaźników (smart pointers)**, takich jak `std::unique_ptr` i `std::shared_ptr`. Zarządzają one pamięcią automatycznie, zwalniając ją, gdy wskaźnik przestaje być potrzebny, co skutecznie eliminuje wycieki pamięci.', False, 'None')"
