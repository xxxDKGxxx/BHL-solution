question,answer
What is a Hash Map?,"('A **Hash Map** (or Hash Table) is an abstract data structure that stores data in **key-value pairs**.\n\n**Concept & Structure:** It uses a hash function to compute an index (or bucket) from a given key, allowing for fast data retrieval. Internally, it is typically implemented using an array where each index potentially points to a linked list or another structure to handle multiple entries.\n\n**Purpose:** To provide efficient insertion, deletion, and lookup of data based on a unique key.\n\n**Average-Case Time Complexity:** $O(1)$ (constant time) for insertion, deletion, and lookup.\n\n**Collision Management:** Data collisions (when two different keys hash to the same index) are commonly managed using **Separate Chaining** (storing colliding entries in a linked list at that index) or **Open Addressing** (finding the next available index in the array).\n\n**Similar Data Structures in Popular Languages:**\n\n*   **Python:** `Dictionary` (`dict`)\n*   **Java:** `HashMap` or `Hashtable`', False, 'None')"
What is the MVC design pattern?,"('The **Model-View-Controller (MVC) design pattern** is a software architectural pattern used primarily for developing user interfaces that separates the application into three interconnected parts.\n\n**Component Responsibilities:**\n\n1.  **Model:** Manages the application data, business logic, and rules. It is responsible for retrieving data from the database, manipulating it, and updating its state.\n2.  **View:** Renders the user interface. It is responsible for displaying the data received from the Model to the user and handling presentation logic.\n3.  **Controller:** Handles user input and mediates between the Model and the View. It receives input from the user (via the View), translates it into actions, and instructs the Model to update its state or the View to update its display.\n\n**Primary Objective:** Its primary objective is the **Separation of Concerns**, isolating the presentation (UI) from the data (business logic), which improves code organization, maintainability, and reusability.\n\n**Popular Frameworks Utilizing MVC:**\n\n1.  **Ruby on Rails** (Ruby)\n2.  **Django** (Python)\n3.  **Spring MVC** (Java)', False, 'None')"
What is a Deadlock?,"(""A **Deadlock** is a state in concurrent computing where two or more processes are permanently blocked because each is waiting for the other to release a resource.\n\n**Defining Necessary Condition:** The essential condition that defines a deadlock is **circular waiting**—a set of processes $\\{P_0, P_1, \\dots, P_n\\}$ such that $P_0$ is waiting for a resource held by $P_1$, $P_1$ is waiting for a resource held by $P_2$, $\\dots$, and $P_n$ is waiting for a resource held by $P_0$.\n\n**Four Required Conditions (Coffman Conditions):** All four of these conditions must hold true simultaneously for a deadlock to occur:\n\n1.  **Mutual Exclusion:** At least one resource must be held in a non-sharable mode (only one process can use it at a time).\n2.  **Hold and Wait:** A process must be holding at least one resource and simultaneously waiting to acquire additional resources currently held by other processes.\n3.  **No Preemption:** Resources cannot be forcibly taken away from a process; they must be voluntarily released by the process holding them after the process completes its task.\n4.  **Circular Wait:** A set of waiting processes must exist, such that $P_i$ is waiting for a resource held by $P_{i+1}$, and $P_n$ is waiting for a resource held by $P_0$.\n\n**Common Strategies:**\n\n1.  **Prevention/Avoidance:** Ensuring that at least one of the four necessary conditions never holds true (e.g., using the Banker's Algorithm).\n2.  **Detection and Recovery:** Allowing deadlocks to occur, detecting them via system algorithms, and then recovering (e.g., terminating one or more processes, or preempting resources)."", False, 'None')"
What is a Closure in JavaScript?,"('A **Closure** in JavaScript is the combination of a function bundled together (enclosed) with references to its surrounding state (the **Lexical Environment**).\n\n**Key Defining Characteristic:** A closure gives you access to an outer function\'s scope from an inner function, even *after* the outer function has finished execution and returned.\n\n**Relationship to Lexical Environment:** A closure ""remembers"" the variables and scope where it was defined (its Lexical Environment). This allows the function to access variables from its parent scope, even when it is executed outside that scope.\n\n**Common Use Cases:**\n\n*   **Data Encapsulation/Private Variables:** Creating private variables that can only be accessed or modified by specific methods within the closure\'s scope.\n*   **Creating Function Factories:** Generating functions dynamically with pre-configured settings or state.\n\n**Simple Code Example:**\n\n```javascript\nfunction makeCounter() {\n  let count = 0; // This \'count\' variable is part of the closure\'s environment\n  return function increment() {\n    count++;\n    return count;\n  };\n}\n\nconst counterA = makeCounter();\nconsole.log(counterA()); // Output: 1 (count is remembered)\nconsole.log(counterA()); // Output: 2\n```', False, 'None')"
What is the difference between an Interface and an Abstract Class?,"('The fundamental difference between an **Interface** and an **Abstract Class** lies in their scope and implementation capabilities within Object-Oriented Programming (OOP).\n\n| Feature | Interface (e.g., Java, C#) | Abstract Class (e.g., Java, C#) |\n| :--- | :--- | :--- |\n| **Purpose** | Defines a contract specifying what methods a class *must* implement (specifying behavior). | Provides a partial implementation and a common base for related subclasses (sharing code). |\n| **Instantiation** | Cannot be instantiated directly. | Cannot be instantiated directly. |\n| **Multiple Use** | A class can implement multiple interfaces. | A class can only inherit from one abstract class. |\n\n**Constraints on Methods:**\n\n*   **Interface:** Traditionally, all methods must be implicitly or explicitly **abstract** (without a body/implementation), though modern interfaces may allow default methods.\n*   **Abstract Class:** Can contain both **abstract methods** (no body) and **concrete methods** (with implementation logic).\n\n**Utilization Keywords:**\n\n1.  **Interface:** A class uses the keyword **`implements`** to utilize an interface (e.g., `class Dog implements Animal`).\n2.  **Abstract Class:** A class uses the keyword **`extends`** or similar inheritance syntax to utilize an abstract class (e.g., `class Square extends Shape`).', False, 'None')"
What is a Load Balancer?,"('A **Load Balancer** is a device or software component that distributes incoming network traffic across a group of backend servers (a server farm or server pool).\n\n**Core Function and Primary Objective:** The core function is to efficiently spread the workload to ensure that no single server becomes overwhelmed. Its primary objective is to maximize throughput, minimize response time, and prevent bottlenecks in high-traffic environments.\n\n**Main Categories of Load Balancing Algorithms:**\n\n1.  **Static Algorithms:** These algorithms distribute traffic based on pre-defined rules, regardless of the current server load.\n    *   *Example:* **Round Robin** (traffic is cycled sequentially through the list of servers).\n2.  **Dynamic Algorithms:** These algorithms distribute traffic based on the current status of the backend servers (e.g., CPU utilization, connection count, response time).\n    *   *Example:* **Least Connection** (new requests are sent to the server with the fewest active connections).\n\n**Key Benefits to a Web Application:**\n\n1.  **High Availability and Fault Tolerance:** If one server fails, the load balancer automatically redirects traffic to the remaining healthy servers, ensuring continuous service.\n2.  **Scalability:** Allows the easy addition or removal of application servers (horizontal scaling) to handle increasing or fluctuating user demand without disruption.', False, 'None')"
What is Microservices Architecture?,"('**Microservices Architecture** is an architectural style where a single application is structured as a collection of small, independent services. Each service runs in its own process, manages its own data, and communicates over lightweight mechanisms.\n\n**Fundamental Difference from Monolithic Architecture:**\n\nIn a **Monolithic Architecture**, all components of the application (front-end, backend logic, and data access layers) are tightly coupled and deployed as a single, unified unit. In contrast, Microservices are **decoupled**, organized around business capabilities, and can be developed, deployed, and scaled independently of one another.\n\n**Primary Communication Mechanism:**\n\nServices primarily communicate using lightweight protocols, most commonly **HTTP/REST** or message brokers (like AMQP) for asynchronous communication.\n\n**Key Advantages for Software Development Teams:**\n\n1.  **Technology Heterogeneity:** Teams can choose the best programming language, database, or framework for each specific service, rather than being locked into a single technology stack.\n2.  **Increased Autonomy and Faster Deployment:** Services can be developed, tested, and deployed individually, allowing teams to deliver updates more frequently and reducing coordination overhead.\n\n**Popular Technologies for Deployment and Management:**\n\n1.  **Docker:** Used for containerizing individual services, ensuring consistent environments across development, testing, and production.\n2.  **Kubernetes (K8s):** An orchestration system used for automatically deploying, scaling, and managing the containerized microservices.', False, 'None')"
What is the CAP Theorem?,"(""The **CAP Theorem** (also known as Brewer's Theorem) is a fundamental principle in distributed computing that states that it is impossible for a distributed data store to simultaneously provide more than two out of the following three properties: Consistency, Availability, and Partition Tolerance.\n\n**The Three Properties:**\n\n1.  **Consistency (C):** Every read request receives the most recent write or an error. All nodes see the same data at the same time.\n2.  **Availability (A):** Every request receives a non-error response, without guaranteeing that the response contains the most recent write. The system remains operational.\n3.  **Partition Tolerance (P):** The system continues to operate despite arbitrary network failures (partitions) that cause some nodes to be unreachable by others.\n\n**Core Constraint:** In the presence of a network partition (which is assumed to be inevitable in large distributed systems), one must choose between Consistency and Availability.\n\n**Trade-offs and Resulting System Types:**\n\n| Priority Choice | Description | Resulting System Type |\n| :--- | :--- | :--- |\n| **CP System (Consistency + Partition Tolerance)** | The system sacrifices availability during a partition to ensure that data remains consistent. Nodes block requests until data synchronization is confirmed. | Typically used by distributed transaction systems (e.g., MongoDB, Redis Cluster). |\n| **AP System (Availability + Partition Tolerance)** | The system sacrifices consistency during a partition to ensure high availability. Nodes respond immediately, potentially serving stale data. | Typically used by highly scalable web services (e.g., Cassandra, CouchDB). |\n\n**Common Preference of Traditional Databases (CP):** Traditional relational databases often prioritize **Consistency (C)** and **Partition Tolerance (P)** (when distributed) because maintaining data integrity is paramount, often resulting in temporary unavailability during network failures."", False, 'None')"
What is Polymorphism in OOP?,"('**Polymorphism** (Greek for ""many forms"") is a core concept in Object-Oriented Programming (OOP) that allows objects of different classes to be treated as objects of a common type.\n\n**Key Principle:** The key defining principle is that a single interface can be used for different underlying forms (types) of data, allowing the same method name to behave differently depending on the object invoking it.\n\n**The Two Main Types of Polymorphism:**\n\n1.  **Compile-Time Polymorphism (Static Polymorphism):** The compiler determines which function to call during compilation.\n    *   *Mechanism:* **Method Overloading** (defining multiple methods with the same name but different parameters within the same class).\n2.  **Run-Time Polymorphism (Dynamic Polymorphism):** The function call is resolved during execution based on the actual object type, not the reference type.\n    *   *Mechanism:* **Method Overriding** (subclasses provide specific implementations for a method that is already defined in the parent class, often involving inheritance).\n\n**Benefits for Code Maintenance and Design:**\n\n1.  **Flexibility and Extensibility:** It allows for the creation of generic, plug-and-play components. New classes can be added without altering the existing code base, provided they adhere to the common interface.\n2.  **Decoupling:** By focusing on the interface rather than the specific implementation, polymorphism reduces tight coupling, making the code easier to maintain, debug, and reuse.', False, 'None')"
What is Database Normalization?,"(""**Database Normalization** is a systematic process of restructuring a relational database to eliminate data redundancy and ensure data dependencies are logical.\n\n**Primary Goal:** The primary goal is to minimize data duplication and improve the integrity, consistency, and efficiency of the database structure.\n\n**The Three Most Common Normal Forms:**\n\n1.  **First Normal Form (1NF):** Requires that all columns in a table contain atomic values (indivisible) and that there are no repeating groups of columns.\n2.  **Second Normal Form (2NF):** Requires the table to be in 1NF, and all non-key attributes must be fully dependent on the entire primary key.\n3.  **Third Normal Form (3NF):** Requires the table to be in 2NF, and there must be no transitive dependencies (non-key attributes cannot depend on other non-key attributes).\n\n**Problems (Anomalies) that Normalization Aims to Eliminate:**\n\n1.  **Insertion Anomaly:** Inability to add data to the database due to the absence of other data (e.g., being unable to add a new department until an employee is assigned to it).\n2.  **Update Anomaly:** Modifying a data item requires updating multiple records, increasing the risk of inconsistency (e.g., updating a professor's office number in 50 different rows).\n3.  **Deletion Anomaly:** Deleting a record unintentionally causes the loss of other, non-related data (e.g., deleting the last employee in a department causes the department's information to be lost)."", False, 'None')"
How does Binary Search work?,"('**Binary Search** is an efficient searching algorithm used to find the position of a target value within a sorted array.\n\n**Mechanism and Core Requirement:**\n\nThe mechanism works by repeatedly dividing the search interval in half. The **core requirement** for Binary Search is that the input array or list must be **sorted** (either ascending or descending order).\n\n**Average-Case Time Complexity:**\n\nBinary Search has a time complexity of **$O(\\log n)$** (logarithmic time), making it significantly faster than linear search ($O(n)$) for large datasets.\n\n**Recursive Steps Involved in the Search Process:**\n\n1.  **Start:** Determine the middle element of the search space.\n2.  **Compare:** Compare the middle element with the target value.\n3.  **Refine:**\n    *   If the target matches the middle element, the search is complete.\n    *   If the target is less than the middle element, the algorithm recursively continues the search in the lower half of the array.\n    *   If the target is greater than the middle element, the algorithm recursively continues the search in the upper half of the array.\n4.  **Terminate:** The process repeats until the target is found or the search space is empty.\n\n**Common Scenarios Where Binary Search is Preferred:**\n\n1.  **Finding Elements in Large, Static Dictionaries/Tables:** When data rarely changes (maintaining the sorted property), Binary Search offers optimal lookup speed.\n2.  **Implementing Number Guessing Games or Searching for Thresholds:** Used to efficiently find the boundary where a condition flips from true to false (e.g., finding the first negative number in a sorted array).', False, 'None')"
What is a JSON Web Token (JWT)?,"('A **JSON Web Token (JWT)** is an open standard (**RFC 7519**) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object.\n\n**Primary Purpose:** The primary purpose of a JWT is for **stateless authentication and authorization**. Once a user logs in, the server generates a JWT, which the client uses to prove its identity on subsequent requests without having to re-authenticate or rely on server-side sessions.\n\n**The Three Standard Components of a JWT:**\n\n1.  **Header:** Contains metadata about the token itself, typically the token type (`JWT`) and the signing algorithm being used (e.g., HMAC SHA256 or RSA).\n2.  **Payload (Claims):** Contains the actual data being transmitted, such as user identity (e.g., user ID), roles, expiration time, and issuer information. These statements about an entity are called ""claims.""\n3.  **Signature:** Created by taking the encoded Header, the encoded Payload, and a secret key, and cryptographically hashing them together.\n\n**Key Security Mechanism:** The key security mechanism is the **Signature**. The recipient (server) uses the secret key to recalculate the signature. If the calculated signature matches the token\'s signature, it proves that the token has not been tampered with and was issued by the trusted party.\n\n**Common Utilization Scenarios:**\n\n1.  **Authorization:** After successful login, the client receives a JWT and includes it in the header of API requests (often as a Bearer token) to access protected resources.\n2.  **Information Exchange:** Securely transmitting small pieces of information between different microservices or applications.', False, 'None')"
What is CORS?,"('**Cross-Origin Resource Sharing (CORS)** is a browser security mechanism that allows web pages running on one origin (domain, protocol, and port) to request resources from a different origin.\n\n**Concept and Necessity:** CORS is necessary because, by default, web browsers block resource requests initiated by scripts if the resource is located on a different origin than the originating page. CORS provides a standardized way for the server to explicitly grant permission for these cross-origin requests.\n\n**Security Policy Relaxed by CORS:** CORS relaxes the strict constraints imposed by the browser’s **Same-Origin Policy (SOP)**, which otherwise prevents nearly all cross-origin requests for security reasons.\n\n**CORS Preflight Request:**\n\nA preflight request is an automatic request sent by the browser **before** the actual cross-origin request. It uses the **`OPTIONS`** HTTP method. Its purpose is to check with the server whether the actual request is safe to send, especially if the request uses complex methods (like PUT, DELETE) or non-standard headers.\n\n**Key Headers Involved in Managing CORS Permissions:**\n\n1.  **`Access-Control-Allow-Origin`:** Sent by the server in the response, specifying which origins are allowed to access the resource (e.g., `*` for all origins, or a specific domain).\n2.  **`Access-Control-Allow-Methods`:** Sent by the server, specifying which HTTP methods (GET, POST, PUT, etc.) are permitted when accessing the resource.\n3.  **`Origin`:** Sent by the browser in the request, indicating the origin of the request to the server.', False, 'None')"
What is Dependency Injection?,"('**Dependency Injection (DI)** is a design pattern in which a component receives its required dependencies from an external source rather than creating them itself.\n\n**Concept and Primary Goal:** The concept is that the responsibility for creating and managing dependencies is shifted away from the dependent class. The primary goal is to achieve **decoupling** between classes, making the code more modular, flexible, and testable.\n\n**Role of Inversion of Control (IoC):** DI is a specific technique used to implement the broader principle of **Inversion of Control (IoC)**. IoC dictates that the flow of control or the responsibility for resource management (including dependencies) is delegated to a framework or external container, rather than being managed manually by the application code.\n\n**Three Common Types of DI Implementation:**\n\n1.  **Constructor Injection:** Dependencies are provided through the class’s constructor. This is the most common method as it ensures the object is initialized with all necessary dependencies.\n2.  **Setter Injection (Property Injection):** Dependencies are provided through setter methods on the dependent class. This allows the dependencies to be optional or modified after instantiation.\n3.  **Interface Injection:** The dependent class implements an interface that defines the setter method for injecting the dependency (less common in modern frameworks).\n\n**Significant Benefits to Software Design:**\n\n1.  **Improved Testability:** Because dependencies are injected externally, they can easily be replaced with mock objects during unit testing without affecting the core logic.\n2.  **Increased Code Reusability and Maintainability:** Decoupled components are easier to swap out, update, and reuse in different parts of the application or entirely new projects.', False, 'None')"
What is GraphQL?,"('**GraphQL** is a modern query language for APIs and a server-side runtime for executing those queries by using a type system defined for your data.\n\n**Primary Function:** Its primary function is to allow client applications to precisely specify the data they need, making data fetching more efficient and flexible than traditional API structures.\n\n**Fundamental Difference from Traditional REST APIs:**\n\nREST typically exposes multiple endpoints, and each endpoint returns a fixed data structure (often including more data than needed). In contrast, GraphQL exposes a single endpoint, allowing the client to send a structured query that dictates exactly *what* fields it requires, eliminating redundant data fetching.\n\n**Defining Characteristic of a GraphQL Query (Data Retrieval):**\n\nThe defining characteristic is that GraphQL queries are **declarative** and **client-driven**. The client always retrieves only the specific fields it requests, leading to either zero **over-fetching** (fetching unnecessary data) or **under-fetching** (needing multiple round trips to get related data).\n\n**Significant Benefits to Client Applications:**\n\n1.  **Reduced Bandwidth Usage:** By fetching only required data fields, mobile and web applications consume less bandwidth and load faster.\n2.  **Faster Development Cycle:** The API structure is strongly typed and self-documenting, enabling developers to prototype and iterate quicker by knowing exactly what data structures are available.', False, 'None')"
What is the difference between Stack and Heap memory?,"('The fundamental difference between Stack and Heap memory lies in their structure, management, and the type of data they store during program execution.\n\n| Feature | Stack Memory | Heap Memory |\n| :--- | :--- | :--- |\n| **Primary Use** | Storing local variables, function calls (stack frames), and return addresses. | Storing dynamically allocated objects and data structures whose size is unknown at compile time. |\n| **Structure** | LIFO (Last-In, First-Out) structure. | Hierarchical structure, resembling a tree or graph. |\n\n**Key Management Characteristics:**\n\n| Characteristic | Stack Memory | Heap Memory |\n| :--- | :--- | :--- |\n| **Allocation Style** | Automatic (handled by the CPU), fast, and linear. | Manual or Managed (via `new` or garbage collection), slower, and random access. |\n| **Size Constraint** | Fixed and relatively small size. | Large and dynamically resized (limited only by physical memory). |\n| **Deallocation** | Automatic when the function returns (scope ends). | Manual (via `delete` in C++) or automatic (via Garbage Collector in Java/Python). |\n\n**Storage of Object Data:**\n\nIn languages like Java or C++ (when using pointers/references), the actual **object data** (the bulk data structure) is typically stored on the **Heap**. However, the **reference or pointer** that points to that object is stored on the **Stack**.', False, 'None')"
What are ACID properties in databases?,"(""The **ACID properties** are a set of guarantees that guarantee that database transactions are processed reliably.\n\n**Concept and Necessity:** The concept centers on ensuring data integrity and reliability, especially during multi-step operations (transactions). They are necessary to protect the database from corruption, even in the event of system failures, errors, or concurrent access.\n\n**Full Definitions of the Four Letters:**\n\n1.  **A - Atomicity:** A transaction must be treated as a single, indivisible unit of work. It either completes entirely (commits) or has no effect at all (rolls back).\n2.  **C - Consistency:** A transaction must bring the database from one valid state to another. Any data written must follow all defined rules, constraints, and cascades.\n3.  **I - Isolation:** Transactions executing concurrently must not interfere with each other. The result must be the same as if the transactions were executed sequentially.\n4.  **D - Durability:** Once a transaction has been committed, the changes are permanent and must persist even if the system fails (e.g., power loss).\n\n**Specific Guarantee of the 'I' Property (Isolation):**\n\nIsolation specifically guarantees that intermediate states of a transaction are hidden from other concurrent transactions. This prevents issues like dirty reads, non-repeatable reads, and phantom reads.\n\n**Popular Database Types that Strictly Enforce ACID:**\n\n1.  **Relational Database Management Systems (RDBMS):** (e.g., PostgreSQL, MySQL, SQL Server)\n2.  **Transactional NoSQL Databases:** (though less common than in RDBMS, some offer strict ACID, such as CockroachDB)."", False, 'None')"
What are WebSockets?,"('**WebSockets** are a communication protocol that provides full-duplex, two-way communication channels over a single, persistent TCP connection.\n\n**Concept and Primary Mechanism:** The mechanism involves upgrading an initial HTTP connection into a continuous, open connection. Once established, both the client and the server can send data to the other party simultaneously and asynchronously without the need for repeated request/response cycles.\n\n**Fundamental Limitation of HTTP Addressed by WebSockets:**\n\nWebSockets address the fundamental limitation of standard **HTTP/1.1**, which is its **stateless and unidirectional** nature (the client must always initiate the request, and the server can only respond). WebSockets allow the server to push data to the client when new information is available, enabling true real-time functionality.\n\n**Protocol Used for Initial Connection Setup (Handshake):**\n\nThe connection is established using a standard **HTTP/1.1** request, specifically utilizing the `Upgrade` header to request protocol switching. If the server supports WebSockets, it responds with an `101 Switching Protocols` status code, and the connection is converted to a WebSocket channel.\n\n**Common Real-Time Applications Relying on WebSockets:**\n\n1.  **Live Chat and Messaging Applications:** Enables instant, bidirectional delivery of messages between users.\n2.  **Live Sports Tickers and Stock Trading Platforms:** Allows servers to push immediate price updates or score changes to thousands of concurrent users.\n3.  **Collaborative Editing Tools:** Facilitates immediate synchronization of changes among multiple editors (e.g., Google Docs).', False, 'None')"
What is Memoization?,"('**Memoization** is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again.\n\n**Concept and Primary Goal:** The concept is to use a cache (often a hash map or array) to store input-output pairs. The primary goal is to **reduce redundant computations** and significantly improve the performance of repeated calls to the same function with identical arguments.\n\n**Specific Condition for Benefit:**\n\nFor a function to benefit from memoization, it must be **pure** or, more accurately, **referentially transparent**. This means the function must always produce the same output for a given input (it must not rely on external state or side effects) and have a sufficiently high computational cost to justify the overhead of managing the cache.\n\n**Time/Space Trade-off:**\n\nMemoization involves a fundamental trade-off: it increases **space complexity** (by storing the cache of results) in exchange for drastically reducing **time complexity** (by avoiding expensive recalculations).\n\n**Concrete Example of Highly Effective Function:**\n\nA classic example is calculating the **Fibonacci sequence** using recursion, especially for large numbers. Without memoization, the function recalculates the same subproblems repeatedly, leading to exponential time complexity ($O(2^n)$).\n\n*   *Example:* Calculating `fib(5)` requires calculating `fib(3)` twice and `fib(2)` three times.\n*   *With Memoization:* The result of `fib(3)` is calculated once, stored, and retrieved instantly the second time it is needed, reducing the complexity to linear time ($O(n)$).', False, 'None')"
What is a Singleton Pattern?,"('The **Singleton Pattern** is a creational design pattern in object-oriented programming.\n\n**Concept and Primary Purpose:** The concept is to restrict the instantiation of a class to one single object. The primary purpose is to control access to some shared resource or service and ensure that all parts of the application utilize the exact same instance.\n\n**Specific Condition Enforced:**\n\nThe Singleton Pattern enforces that a class can have **only one instance** throughout the entire application lifecycle. This is usually achieved by making the constructor of the class private.\n\n**Mechanism for Global Access:**\n\nGlobal access to the single instance is typically provided through a **public static method** (often named `getInstance()` or `Instance`). This method checks if an instance of the class already exists; if not, it creates the single instance, and then always returns that same instance on subsequent calls.\n\n**Common, Practical Use Cases:**\n\n1.  **Logging Service:** Using a single instance of a logger ensures that all log messages are channeled to the same file or stream in the correct chronological order, preventing concurrency issues.\n2.  **Configuration Manager/Settings Object:** Ensures that all parts of the application read from and write to the same set of application-wide configuration parameters.\n3.  **Database Connection Pool:** Managing a single pool of connections to the database to control resource usage and optimize performance.', False, 'None')"
