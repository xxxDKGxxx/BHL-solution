question,answer
Czym jest rekurencja?,"('**Rekurencja** to technika programowania polegająca na definiowaniu funkcji (lub procedury) poprzez odwoływanie się przez nią do samej siebie w celu rozwiązania problemu.\n\n### Mechanizm działania\n\nDziałanie rekurencyjne polega na dzieleniu złożonego problemu na mniejsze, identyczne podproblemy. Funkcja wywołuje samą siebie z nowymi, uproszczonymi argumentami, aż do osiągnięcia najprostszej postaci, która może być rozwiązana bezpośrednio.\n\n**Warunek bazowy (Warunek stopu):** Jest to kluczowy element każdej rekurencji. Warunek bazowy to definicja najprostszego przypadku, który *nie* wywołuje funkcji rekurencyjnie, tym samym przerywając dalsze wywołania i zapobiegając nieskończonej pętli. Gdy warunek bazowy jest spełniony, wywołania zaczynają się zwijać ze stosu (stack), zwracając wyniki w odwrotnej kolejności.\n\n### Zastosowania\n\nRekurencja jest powszechnie stosowana w:\n\n1.  **Obliczeniach matematycznych:** Obliczanie silni ($n!$) i generowanie ciągu Fibonacciego.\n2.  **Algorytmach sortowania:** Algorytmy takie jak Quicksort i Mergesort.\n3.  **Strukturach danych:** Przetwarzanie i przeszukiwanie struktur drzewiastych oraz grafów.\n\n**Fakt dodatkowy:** Implementacja rekursywna jest często bardziej elegancka i intuicyjna niż iteracyjna, ale wiąże się z większym narzutem pamięciowym, ponieważ wymaga użycia stosu wywołań do przechowywania stanu każdego kolejnego wywołania funkcji.', False, 'None')"
Jak działa Garbage Collector w Javie?,"('Garbage Collector (GC) w Javie jest automatycznym systemem zarządzania pamięcią, który zwalnia miejsce na stercie (Heap) zajmowane przez obiekty, które nie są już dostępne (osiągalne) dla działającego programu. Eliminuje to potrzebę manualnego zarządzania pamięcią przez programistę.\n\n### Mechanizm Działania\n\nGC działa w dwóch podstawowych fazach:\n\n1.  **Faza Oznaczania (Marking):** GC identyfikuje tzw. ""korzenie"" (roots – zmienne lokalne, aktywne wątki, klasy załadowane), a następnie śledzi wszystkie połączenia wychodzące od tych korzeni. Każdy obiekt, do którego można dotrzeć z korzenia, jest oznaczany jako *żywy*.\n2.  **Faza Usuwania/Kompaktowania (Sweep/Compact):** Obiekty, które pozostały nieoznaczone (niedostępne), są usuwane, a ich pamięć jest zwalniana. Niektóre algorytmy (np. CMS) wykonują tylko usuwanie (Sweep), pozostawiając fragmentację, podczas gdy inne (np. G1) lub operacje w Starej Generacji wykonują **Kompaktowanie**, przesuwając żywe obiekty, aby skonsolidować wolną pamięć.\n\n### Kluczowe Koncepcje (Generacje)\n\nWiększość implementacji GC wykorzystuje **Hipotezę Generacyjną** (Generational Hypothesis), która zakłada, że większość obiektów umiera młodo. Z tego powodu sterta Javy jest podzielona na generacje, aby optymalizować czas czyszczenia:\n\n*   **Młoda Generacja (Young Generation):** Przeznaczona dla nowo utworzonych obiektów. Czyszczenie jest szybkie (Minor GC). Składa się ze Strefy Eden oraz dwóch Stref Ocalałych (Survivor Spaces).\n*   **Stara Generacja (Old/Tenured Generation):** Obiekty, które przeżyły wystarczająco dużo cykli Minor GC, są przenoszone do tej strefy. Czyszczenie (Major GC) jest rzadsze, ale zwykle trwa dłużej.\n\n### Popularne Algorytmy GC (w środowisku JVM)\n\nW zależności od priorytetów (przepustowość vs. czas pauzy), JVM oferuje różne algorytmy:\n\n1.  **Serial GC:** Najprostszy, jednowątkowy, często używany w małych aplikacjach klienckich.\n2.  **Parallel GC (Throughput Collector):** Wykorzystuje wiele wątków do czyszczenia, optymalizując ogólną przepustowość aplikacji.\n3.  **CMS (Concurrent Mark Sweep):** Algorytm zorientowany na niskie czasy pauzy, wykonujący większość pracy *równolegle* z aplikacją (obecnie oznaczony jako przestarzały).\n4.  **G1 (Garbage First):** Obecnie domyślny w wielu wersjach Javy. Dzieli stertę na regiony i próbuje zminimalizować czas pauzy, koncentrując się na czyszczeniu regionów z największą ilością śmieci.\n\n**Dodatkowy fakt:** Podczas gdy nowoczesne algorytmy (G1, ZGC) dążą do minimalizacji przerw, każdy cykl zbierania pamięci musi zawierać moment **""Stop-the-World"" (STW)**, w którym wszystkie wątki aplikacji są zatrzymywane, aby GC mógł bezpiecznie ustalić stan obiektu i zaktualizować wskaźniki.', False, 'None')"
Co to jest REST API?,"('**REST API** (Representational State Transfer Application Programming Interface) to styl architektoniczny do projektowania rozproszonych systemów hipermedialnych (takich jak Internet). Został sformalizowany przez Roya Fieldinga w 2000 roku.\n\n### Kluczowe Zasady (Ograniczenia) Architektury REST\n\nAby interfejs API był uważany za ""RESTful"", musi przestrzegać zestawu ograniczeń, w tym:\n\n1.  **Klient-Serwer (Client-Server):** Separacja interesów między interfejsem użytkownika a magazynem danych.\n2.  **Bezstanowość (Stateless):** Każde żądanie od klienta do serwera musi zawierać wszystkie informacje niezbędne do jego zrozumienia i przetworzenia. Serwer nie może przechowywać żadnego kontekstu klienta między kolejnymi żądaniami.\n3.  **Możliwość buforowania (Cacheable):** Odpowiedzi muszą być jawnie oznaczone jako buforowalne lub niebuforowalne, aby poprawić wydajność.\n4.  **Ujednolicony interfejs (Uniform Interface):** Jest to kluczowe ograniczenie. Wymaga on:\n    *   Identyfikacji zasobów (Resources) – wszystkie zasoby są identyfikowane przez URI.\n    *   Manipulacji zasobami poprzez reprezentacje (Representations).\n    *   Wiadomości opisujących się samodzielnie (Self-descriptive Messages).\n    *   HATEOAS (Hypermedia As The Engine of Application State) – Serwer powinien dostarczać hiperłącza, umożliwiając klientowi nawigację po API bez wcześniejszej znajomości jego struktury.\n\n### Metody HTTP w Komunikacji REST-owej\n\nREST wykorzystuje standardowe metody protokołu HTTP do wykonywania operacji na zasobach (CRUD – Create, Read, Update, Delete):\n\n| Metoda HTTP | Odpowiednik CRUD | Działanie na zasobie |\n| :---------- | :--------------- | :------------------- |\n| **GET**     | Read             | Pobieranie (odczyt) reprezentacji zasobu. |\n| **POST**    | Create           | Tworzenie nowego zasobu. |\n| **PUT**     | Update           | Zastąpienie/aktualizacja całego zasobu. |\n| **DELETE**  | Delete           | Usunięcie zasobu. |\n| **PATCH**   | Update (Partial) | Częściowa modyfikacja zasobu. |\n\n**Dodatkowy fakt:** Najczęściej używanymi formatami danych do wymiany reprezentacji zasobów w REST API są **JSON** (JavaScript Object Notation) oraz, rzadziej, XML. JSON stał się de facto standardem ze względu na jego lekkość i łatwość parsowania.', False, 'None')"
Jaka jest różnica między listą a krotką w Pythonie?,"(""Kluczową różnicą między listą (list) a krotką (tuple) w Pythonie jest ich **mutowalność** (zmienność).\n\nLista jest **mutowalna** – jej elementy można zmieniać, dodawać lub usuwać po utworzeniu. Krotka jest **niemutowalna** – raz utworzona, jej zawartość nie może być zmieniona.\n\n| Cecha | Lista (List) | Krotka (Tuple) |\n| :--- | :--- | :--- |\n| **Mutowalność** | Zmienna (Mutable) | Niezmienna (Immutable) |\n| **Konstrukcja** | Nawiasy kwadratowe `[ ]` | Nawiasy okrągłe `( )` |\n\n### Konstrukcja Składniowa\n\n*   **Lista:** `moja_lista = [1, 'a', 3.14]`\n*   **Krotka:** `moja_krotka = (1, 'a', 3.14)` (Nawiasy okrągłe są opcjonalne, ale zalecane dla czytelności).\n\n### Wpływ Różnicy na Wydajność\n\nPonieważ krotki są niemutowalne:\n\n1.  **Wydajność (Performance):** Krotki są nieznacznie szybsze w dostępie i iteracji niż listy, ponieważ interpreter Pythona może dokonywać większej optymalizacji, wiedząc, że ich rozmiar i zawartość się nie zmienią.\n2.  **Zużycie Pamięci:** Krotki wymagają mniej pamięci niż listy.\n3.  **Bezpieczeństwo (Hashowalność):** Krotki mogą być używane jako klucze w słownikach (ponieważ są hashowalne), podczas gdy listy nie mogą.\n\n### Scenariusze Zastosowania\n\n| Struktura | Typowe Scenariusze Zastosowania |\n| :--- | :--- |\n| **Lista** | Kolekcje, które wymagają częstej modyfikacji, zarządzanie dynamicznymi zbiorami danych (np. kolejka, stos). |\n| **Krotka** | Stałe zbiory danych, rekordy (np. współrzędne geograficzne), funkcja zwracająca wiele wartości, przekazywanie danych do funkcji, gdzie nie chcemy, aby zostały one przypadkowo zmienione. |\n\n**Dodatkowy fakt:** Pomimo tego, że krotki są niemutowalne, jeśli krotka zawiera obiekty mutowalne (np. listę), zawartość tego zagnieżdżonego obiektu mutowalnego może być zmieniona, chociaż sama krotka i jej referencja pozostają stałe."", False, 'None')"
Do czego służy polecenie git commit?,"('Polecenie `git commit` służy do **trwałego zapisania (utrwalenia) bieżącego stanu plików** w lokalnym repozytorium Git. Każde zatwierdzenie tworzy migawkę projektu w określonym momencie, budując tym samym historyczną linię zmian.\n\n### Relacja ze Staging Area\n\n`git commit` nie zapisuje automatycznie wszystkich zmian wprowadzonych w katalogu roboczym. Zapisuje tylko te zmiany, które zostały uprzednio przygotowane i dodane do **Staging Area (Indeksu)** za pomocą polecenia `git add`.\n\n*   **Proces:** Modyfikujesz pliki w katalogu roboczym $\\rightarrow$ Używasz `git add` do wybrania konkretnych zmian do Staging Area $\\rightarrow$ Używasz `git commit` do zapisania zawartości Staging Area jako nowej, niezmiennej wersji projektu.\n\n### Wymagane Elementy Commitu\n\nKażde zatwierdzenie (commit) w Git musi zawierać:\n\n1.  **Migawkę (Snapshot):** Dokładny stan plików znajdujących się w Staging Area.\n2.  **Metadane:**\n    *   **Unikalny Hash (SHA-1):** Identyfikator commita.\n    *   **Wskaźnik Rodzica (Parent Pointer):** Referencja do poprzedniego commita, co tworzy historię.\n    *   **Autor i Datownik (Author and Timestamp).**\n3.  **Wiadomość (Commit Message):** Krótki opis zmian wprowadzonych w tym commicie.\n\n### Zalety dla Historii Projektu\n\nGłówną zaletą użycia `git commit` jest tworzenie **niezmiennej, czytelnej i śledzalnej historii projektu**. Pozwala to:\n\n*   Łatwo wracać do poprzednich, działających stanów projektu (rollback).\n*   Lokalizować błędy (np. używając `git bisect`).\n*   Zrozumieć, dlaczego dana zmiana została wprowadzona (dzięki treści wiadomości).\n\n**Fakt dodatkowy:** Wiadomość commita powinna składać się z krótkiego podsumowania (maks. 50 znaków) i opcjonalnego, bardziej szczegółowego opisu oddzielonego pustą linią. Jest to konwencja ułatwiająca przeglądanie historii.', False, 'None')"
Czym jest SQL Injection?,"(""**SQL Injection (SQLi)** to jeden z najczęstszych typów ataków cybernetycznych, polegający na wstrzykiwaniu złośliwego kodu SQL (Structured Query Language) do zapytania, które ma być wykonane w bazie danych.\n\n### Mechanizm Działania\n\nAtak wykorzystuje luki w aplikacjach, które bezpośrednio wklejają dane wejściowe użytkownika (np. z formularzy logowania, pól wyszukiwania) do dynamicznie budowanych zapytań SQL, bez odpowiedniego oczyszczania i walidacji tych danych.\n\n**Przykład luki:**\n\nJeśli oryginalne zapytanie brzmi:\n`SELECT * FROM users WHERE username = 'WPROWADZONY_TEKST' AND password = '...';`\n\nAtakujący może wprowadzić tekst: `' OR '1'='1`\n\nco zmieni zapytanie wykonywane przez serwer na:\n`SELECT * FROM users WHERE username = '' OR '1'='1' AND password = '...';`\n\nPonieważ `'1'='1'` jest zawsze prawdziwe, zapytanie może ominąć weryfikację hasła lub zwrócić całą tabelę użytkowników.\n\n### Potencjalne Konsekwencje\n\nSkutki udanego ataku SQLi mogą być katastrofalne dla organizacji:\n\n1.  **Ujawnienie i kradzież danych:** Wyciągnięcie całej zawartości bazy danych (np. danych klientów, haseł, informacji finansowych).\n2.  **Modyfikacja/Uszkodzenie danych:** Zmiana lub usunięcie danych (np. zmiana uprawnień użytkowników, usunięcie tabel).\n3.  **Wzrost uprawnień:** Przejęcie konta administracyjnego.\n4.  **Odmowa usługi (DoS):** Zablokowanie działania aplikacji poprzez wykonanie nadmiernie złożonych zapytań.\n\n### Metody Zapobiegania\n\nPodstawową zasadą jest nigdy nie ufanie danym wejściowym od użytkownika. Kluczowe metody obrony to:\n\n1.  **Parametryzowane Zapytania (Prepared Statements):** Użycie zmiennych wiązanych (placeholders) zamiast konkatenacji stringów. Pozwala to na oddzielenie logiki zapytania SQL od danych. Interpreter bazy danych traktuje wstrzyknięte dane jako literalne wartości, a nie jako część kodu.\n2.  **Walidacja Danych Wejściowych:** Sprawdzanie, czy dane wprowadzone przez użytkownika mają oczekiwany format, typ i długość (np. numery są tylko numeryczne).\n3.  **Zasada Najmniejszego Uprawnienia (Principle of Least Privilege):** Użytkownik bazy danych używany przez aplikację powinien mieć tylko minimalne uprawnienia niezbędne do działania (np. brak możliwości usuwania tabel, jeśli nie jest to wymagane).\n\n**Fakt dodatkowy:** Ataki SQL Injection są tak poważne, że konsekwentnie zajmują czołowe miejsca na liście **OWASP Top 10** (najważniejszych zagrożeń bezpieczeństwa aplikacji webowych)."", False, 'None')"
Co oznacza akronim SOLID?,"('Akronim **SOLID** jest zbiorem pięciu podstawowych zasad projektowania obiektowego, które mają na celu tworzenie systemów łatwiejszych w utrzymaniu, skalowalnych i elastycznych. Zasady te zostały skodyfikowane przez Roberta C. Martina (""Uncle Bob"").\n\n### Rozwinięcie Akronimu SOLID\n\n| Litera | Pełna Nazwa (Zasada) |\n| :--- | :--- |\n| **S** | **Single Responsibility Principle** (Zasada Pojedynczej Odpowiedzialności) |\n| **O** | **Open/Closed Principle** (Zasada Otwarte/Zamknięte) |\n| **L** | **Liskov Substitution Principle** (Zasada Podstawienia Liskov) |\n| **I** | **Interface Segregation Principle** (Zasada Segregacji Interfejsów) |\n| **D** | **Dependency Inversion Principle** (Zasada Odwrócenia Zależności) |\n\n### Cel Zastosowania w Inżynierii Oprogramowania\n\nStosowanie zasad SOLID ma na celu redukcję złożoności kodu, minimalizację zależności między modułami oraz ułatwienie refaktoryzacji i wprowadzania nowych funkcjonalności. W rezultacie powstaje kod: **luźno sprzężony (loosely coupled)** i **spójny (highly cohesive)**.\n\n### Krótki Opis Zasad\n\n**S – Single Responsibility Principle (Pojedyncza Odpowiedzialność):**\nKlasa powinna mieć tylko jeden powód do zmiany, co oznacza, że powinna być odpowiedzialna za jeden, jasno określony aspekt funkcjonalności.\n\n**O – Open/Closed Principle (Otwarte/Zamknięte):**\nJednostki oprogramowania (klasy, moduły) powinny być **otwarte na rozszerzenia**, ale **zamknięte na modyfikacje**. Oznacza to, że nową funkcjonalność należy dodawać przez rozszerzanie (dziedziczenie/implementację), a nie poprzez zmianę istniejącego, przetestowanego kodu.\n\n**L – Liskov Substitution Principle (Podstawienie Liskov):**\nObiekty w programie powinny być możliwe do zastąpienia instancjami ich podtypów (klas pochodnych) bez naruszania poprawności działania programu. W skrócie: typy pochodne muszą być w pełni kompatybilne z typami bazowymi.\n\n**I – Interface Segregation Principle (Segregacja Interfejsów):**\nInterfejsy powinny być wąskie i specyficzne dla klienta. Klasa nie powinna być zmuszana do implementowania metod, których nie używa. Lepiej mieć wiele małych, spójnych interfejsów niż jeden duży.\n\n**D – Dependency Inversion Principle (Odwrócenie Zależności):**\nModuły wysokiego poziomu nie powinny zależeć od modułów niskiego poziomu. Oba powinny zależeć od **abstrakcji** (interfejsów). Abstrakcje nie powinny zależeć od szczegółów; szczegóły powinny zależeć od abstrakcji.\n\n**Dodatkowy fakt:** Choć Robert C. Martin skodyfikował i spopularyzował SOLID, twórczynią Zasady Podstawienia (L) jest w rzeczywistości amerykańska informatyczka **Barbara Liskov**.', False, 'None')"
Czym jest Docker?,"('**Docker** to otwarta platforma do rozwijania, dostarczania i uruchamiania aplikacji w kontenerach. Konteneryzacja pozwala na zapakowanie aplikacji wraz z całym jej środowiskiem (bibliotekami, zależnościami i konfiguracją) w jeden, przenośny i izolowany pakiet.\n\n### Kluczowa Różnica: Kontenery vs. Maszyny Wirtualne (VM)\n\nGłówna różnica polega na sposobie współdzielenia zasobów i izolacji.\n\n| Cecha | Kontenery Docker | Maszyny Wirtualne (VM) |\n| :--- | :--- | :--- |\n| **System Operacyjny** | Współdzielą system operacyjny hosta i jądro (kernel). | Każda VM ma własny, pełny system operacyjny gościa. |\n| **Warstwa Wirtualizacji** | Silnik kontenerowy (np. Docker Engine) | Hypervisor (np. VMware, VirtualBox) |\n| **Rozmiar** | Bardzo małe (megabajty) | Duże (gigabajty) |\n| **Start** | Prawie natychmiastowy (sekundy) | Długi (minuty) |\n| **Izolacja** | Izolacja na poziomie procesów i jądra. | Pełna izolacja sprzętowa i systemowa. |\n\nKontenery są znacznie lżejsze, ponieważ eliminują narzut związany z uruchamianiem pełnego systemu operacyjnego w każdym przypadku.\n\n### Podstawowe Elementy Ekosystemu Docker\n\nEkosystem Docker opiera się na dwóch głównych elementach:\n\n1.  **Obrazy (Images):**\n    *   Są to **szablony** zawierające wszystkie instrukcje i warstwy potrzebne do uruchomienia aplikacji (kod, środowisko uruchomieniowe, biblioteki, zmienne środowiskowe).\n    *   Obraz jest **niemutowalny** (read-only).\n    *   Są budowane za pomocą pliku **Dockerfile**.\n2.  **Kontenery (Containers):**\n    *   Są to **uruchomione instancje** obrazów.\n    *   Są lekkimi, izolowanymi środowiskami wykonawczymi.\n    *   Wszelkie zmiany wprowadzone w działającym kontenerze są zapisywane w **zapisywalnej warstwie** (writable layer) na górze niemutowalnego obrazu.\n\n**Dodatkowy fakt:** Docker wykorzystuje mechanizmy jądra Linux, takie jak **cgroups** (do zarządzania i ograniczania zasobów) oraz **namespaces** (do izolacji procesów i sieci), aby osiągnąć lekkość i izolację kontenerów.', False, 'None')"
Co to jest złożoność obliczeniowa Big O?,"('**Złożoność obliczeniowa Big O (Duże O)** jest notacją matematyczną używaną w informatyce do opisu **granicy tempa wzrostu** czasu działania (lub wykorzystania pamięci) algorytmu w miarę wzrostu wielkości danych wejściowych ($n$). Określa ona **najgorszy przypadek** (worst-case scenario) działania algorytmu.\n\n### Co mierzy Big O?\n\nNotacja Big O mierzy **skalowanie** algorytmu. Nie podaje dokładnego czasu wykonania w sekundach, ale określa, jak wydajność algorytmu zmienia się proporcjonalnie do wielkości problemu ($n$).\n\nW analizie złożoności Big O koncentruje się na:\n\n1.  **Dominujących Wyrazach:** Ignorowane są stałe współczynniki i wyrazy niższego rzędu, ponieważ w przypadku bardzo dużych $n$ mają one znikomy wpływ na wynik końcowy.\n2.  **Czas a $n$:** Mierzona jest liczba operacji, które musi wykonać algorytm w funkcji liczby elementów wejściowych.\n\n### Najczęściej Spotykane Klasy Złożoności\n\nKlasy złożoności są uszeregowane od najbardziej pożądanych (najszybszych) do najmniej pożądanych (najwolniejszych) w miarę wzrostu $n$:\n\n| Notacja Big O | Nazwa | Przykład |\n| :--- | :--- | :--- |\n| $\\text{O}(1)$ | Stała | Dostęp do elementu tablicy po indeksie. |\n| $\\text{O}(\\log n)$ | Logarytmiczna | Wyszukiwanie binarne. |\n| $\\text{O}(n)$ | Liniowa | Przeglądanie wszystkich elementów listy. |\n| $\\text{O}(n \\log n)$ | Liniowo-logarytmiczna | Wydajne algorytmy sortowania (np. Mergesort, Quicksort). |\n| $\\text{O}(n^2)$ | Kwadratowa | Proste algorytmy sortowania (np. Bubble Sort). |\n| $\\text{O}(2^n)$ | Wykładnicza | Niektóre problemy rekurencyjne (np. naiwna rekurencja Fibonacciego). |\n\n### Kluczowe Znaczenie w Projektowaniu Algorytmów\n\nBig O jest kluczowe, ponieważ umożliwia programistom:\n\n1.  **Porównywanie Algorytmów:** Pozwala na obiektywną ocenę, który algorytm jest lepszy dla danego zestawu danych, niezależnie od specyfikacji sprzętowej komputera.\n2.  **Przewidywanie Wydajności:** Umożliwia prognozowanie, jak zachowa się aplikacja, gdy ilość przetwarzanych danych drastycznie wzrośnie.\n3.  **Optymalizację:** Identyfikowanie wąskich gardeł i nieefektywnych fragmentów kodu, które dominują w całkowitym czasie działania.\n\n**Fakt dodatkowy:** Oprócz Big O ($\\text{O}$, miara pesymistyczna), istnieją inne notacje opisujące granice złożoności: **Big Omega ($\\Omega$)** opisująca dolną granicę (najlepszy przypadek) oraz **Big Theta ($\\Theta$)** opisująca ścisłą granicę (gdy najlepszy i najgorszy przypadek mają ten sam rząd złożoności).', False, 'None')"
Na czym polega dziedziczenie w OOP?,"('**Złożoność obliczeniowa Big O (Duże O)** jest notacją matematyczną używaną w informatyce do opisu **granicy tempa wzrostu** czasu działania (lub wykorzystania pamięci) algorytmu w miarę wzrostu wielkości danych wejściowych ($n$). Określa ona **najgorszy przypadek** (worst-case scenario) działania algorytmu.\n\n### Co mierzy Big O?\n\nNotacja Big O mierzy **skalowanie** algorytmu. Nie podaje dokładnego czasu wykonania w sekundach, ale określa, jak wydajność algorytmu zmienia się proporcjonalnie do wielkości problemu ($n$).\n\nW analizie złożoności Big O koncentruje się na:\n\n1.  **Dominujących Wyrazach:** Ignorowane są stałe współczynniki i wyrazy niższego rzędu, ponieważ w przypadku bardzo dużych $n$ mają one znikomy wpływ na wynik końcowy.\n2.  **Czas a $n$:** Mierzona jest liczba operacji, które musi wykonać algorytm w funkcji liczby elementów wejściowych.\n\n### Najczęściej Spotykane Klasy Złożoności\n\nKlasy złożoności są uszeregowane od najbardziej pożądanych (najszybszych) do najmniej pożądanych (najwolniejszych) w miarę wzrostu $n$:\n\n| Notacja Big O | Nazwa | Przykład |\n| :--- | :--- | :--- |\n| $\\text{O}(1)$ | Stała | Dostęp do elementu tablicy po indeksie. |\n| $\\text{O}(\\log n)$ | Logarytmiczna | Wyszukiwanie binarne. |\n| $\\text{O}(n)$ | Liniowa | Przeglądanie wszystkich elementów listy. |\n| $\\text{O}(n \\log n)$ | Liniowo-logarytmiczna | Wydajne algorytmy sortowania (np. Mergesort, Quicksort). |\n| $\\text{O}(n^2)$ | Kwadratowa | Proste algorytmy sortowania (np. Bubble Sort). |\n| $\\text{O}(2^n)$ | Wykładnicza | Niektóre problemy rekurencyjne (np. naiwna rekurencja Fibonacciego). |\n\n### Kluczowe Znaczenie w Projektowaniu Algorytmów\n\nBig O jest kluczowe, ponieważ umożliwia programistom:\n\n1.  **Porównywanie Algorytmów:** Pozwala na obiektywną ocenę, który algorytm jest lepszy dla danego zestawu danych, niezależnie od specyfikacji sprzętowej komputera.\n2.  **Przewidywanie Wydajności:** Umożliwia prognozowanie, jak zachowa się aplikacja, gdy ilość przetwarzanych danych drastycznie wzrośnie.\n3.  **Optymalizację:** Identyfikowanie wąskich gardeł i nieefektywnych fragmentów kodu, które dominują w całkowitym czasie działania.\n\n**Fakt dodatkowy:** Oprócz Big O ($\\text{O}$, miara pesymistyczna), istnieją inne notacje opisujące granice złożoności: **Big Omega ($\\Omega$)** opisująca dolną granicę (najlepszy przypadek) oraz **Big Theta ($\\Theta$)** opisująca ścisłą granicę (gdy najlepszy i najgorszy przypadek mają ten sam rząd złożoności).', True, 'None')"
Czym są Promises w JavaScript?,"('**Promises (Obietnice)** w JavaScript to obiekty, które reprezentują ostateczne zakończenie (lub niepowodzenie) operacji asynchronicznej i jej wynikową wartość. Działają jako kontener na przyszłą wartość.\n\n### Problem Rozwiązywany przez Promises\n\nPromises zostały wprowadzone, aby rozwiązać problem **Callback Hell (Piekła wywołań zwrotnych)**. W tradycyjnym programowaniu asynchronicznym, wiele zagnieżdżonych wywołań zwrotnych (callbacków) utrudniało czytanie, utrzymywanie i obsługę błędów w kodzie. Promises wprowadzają sekwencyjny i bardziej płaski sposób zarządzania przepływem sterowania asynchronicznego.\n\n### Trzy Kluczowe Stany Obiektu Promise\n\nObiekt Promise zawsze znajduje się w jednym z trzech wzajemnie wykluczających się stanów:\n\n1.  **Pending (Oczekujący):** Stan początkowy; operacja asynchroniczna jeszcze się nie zakończyła (nie została ani spełniona, ani odrzucona).\n2.  **Fulfilled/Resolved (Spełniony):** Oznacza, że operacja asynchroniczna zakończyła się **sukcesem**, a obietnica ma dostępną wartość wynikową.\n3.  **Rejected (Odrzucony):** Oznacza, że operacja asynchroniczna zakończyła się **niepowodzeniem** (błędem), a obietnica ma dostępny powód odrzucenia (error).\n\nObietnica jest stabilna (settled) i **niezmienna** (immutable), gdy przechodzi ze stanu *Pending* do *Fulfilled* lub *Rejected*.\n\n### Przykłady Użycia Metod\n\nPo utworzeniu obiektu Promise, można dołączyć do niego akcje, które mają zostać wykonane po spełnieniu lub odrzuceniu obietnicy, używając metod łańcuchowych (chaining):\n\n#### 1. `.then()`\n\nMetoda `.then()` służy do obsługi rezultatu spełnionej obietnicy. Może przyjmować dwa argumenty: funkcję obsługi sukcesu i opcjonalną funkcję obsługi błędu.\n\n```javascript\npobierzDane()\n    .then(wynik => {\n        // Wykonywane, gdy Promise jest Fulfilled\n        console.log(""Dane pobrane:"", wynik);\n    });\n```\n\n#### 2. `.catch()`\n\nMetoda `.catch()` jest skrótem dla `.then(null, obsługaBłędu)` i służy do obsługi błędów (obietnicy w stanie *Rejected*).\n\n```javascript\npobierzDane()\n    .then(wynik => {\n        // ... sukces\n    })\n    .catch(blad => {\n        // Wykonywane, gdy Promise jest Rejected\n        console.error(""Wystąpił błąd:"", blad);\n    });\n```\n\n**Dodatkowy fakt:** Promise Chain (łączenie obietnic) jest możliwe, ponieważ metody `.then()` i `.catch()` same zwracają nową Obietnicę, pozwalając na sekwencyjne przetwarzanie asynchroniczne. Mechanizm ten jest bazą dla składni **`async/await`** (wprowadzonej w ES2017), która jest tylko cukrem składniowym nad klasycznymi Promises.', False, 'None')"
Co to jest klucz główny (Primary Key)?,"('**Klucz główny (Primary Key)** to kolumna (lub zestaw kolumn) w relacyjnej bazie danych, która jednoznacznie identyfikuje każdy wiersz (rekord) w tabeli. Jest to fundamentalny element zapewniający integralność danych.\n\n### Kluczowe Cechy (Wymagania)\n\nAby kolumna mogła funkcjonować jako klucz główny, musi spełniać dwa kluczowe ograniczenia (constraints):\n\n1.  **Unikatowość (Uniqueness):** Wartość klucza głównego musi być unikalna w każdym wierszu tabeli. Nie mogą istnieć dwa rekordy z tą samą wartością klucza.\n2.  **Niepustość (NOT NULL):** Wartość klucza głównego nie może być pusta (NULL). Musi mieć zawsze przypisaną wartość.\n\n### Cel Stosowania Klucza Głównego\n\nGłównym celem stosowania klucza głównego jest:\n\n*   **Identyfikacja:** Zapewnienie szybkiego i jednoznacznego sposobu odwoływania się do pojedynczego rekordu.\n*   **Integralność Encji:** Utrzymanie spójności danych poprzez wymuszenie unikalności i niepustości.\n*   **Wydajność:** Klucze główne są automatycznie indeksowane, co przyspiesza operacje wyszukiwania i odzyskiwania danych.\n\n### Relacja Klucz Główny (Primary Key) a Klucz Obcy (Foreign Key)\n\nKlucz obcy to mechanizm stosowany do ustanawiania i wymuszania relacji między dwiema tabelami.\n\n*   **Klucz Główny (PK):** Definiuje rekord unikalnie w **tabeli źródłowej (tabeli rodzica)**.\n*   **Klucz Obcy (FK):** Jest to kolumna w **tabeli docelowej (tabeli dziecka)**, która odwołuje się do klucza głównego innej tabeli.\n\nKlucz obcy zapewnia **Integralność Referencyjną**, gwarantując, że wartości w kolumnie FK w tabeli dziecka zawsze odpowiadają istniejącym wartościom PK w tabeli rodzica, zapobiegając tym samym „wiszącym” rekordom.\n\n**Fakt dodatkowy:** Jeśli klucz główny składa się z więcej niż jednej kolumny, nazywany jest **kluczem złożonym (Composite Key)**. Wszystkie kolumny w kluczu złożonym muszą być niepuste i ich *kombinacja* musi być unikalna w obrębie tabeli.', False, 'None')"
Czym jest framework React?,"('**React (często nazywany ReactJS)** to otwarta biblioteka JavaScript służąca do budowania interfejsów użytkownika (UI). Została stworzona i jest utrzymywana przez firmę Meta (dawniej Facebook). React koncentruje się na warstwie widoku (View Layer) w architekturze MVC.\n\n### Kluczowe Koncepcje Działania\n\nDziałanie React opiera się na dwóch fundamentalnych koncepcjach:\n\n1.  **Komponenty (Components):**\n    *   Interfejs użytkownika jest dzielony na niezależne, wielokrotnego użytku bloki kodu. Komponenty mogą być definiowane jako funkcje (Functional Components) lub klasy (Class Components).\n    *   Zarządzają one własnym stanem (State) i przyjmują dane wejściowe (Props – Properties).\n\n2.  **Virtual DOM (Wirtualny DOM):**\n    *   Jest to lekka, abstrakcyjna kopia rzeczywistego Document Object Model (DOM) przechowywana w pamięci.\n    *   Gdy stan komponentu się zmienia, React najpierw aktualizuje Virtual DOM. Następnie porównuje (operacja *diffing*) nowy stan Virtual DOM ze starym, identyfikując minimalną liczbę zmian potrzebnych do odświeżenia strony.\n    *   Dzięki temu React aktualizuje tylko te węzły w Rzeczywistym DOM, które faktycznie się zmieniły, co drastycznie optymalizuje wydajność w porównaniu do bezpośredniej manipulacji Rzeczywistym DOM.\n\n### Podstawowe Zalety w Tworzeniu UI\n\n*   **Deklaratywny charakter:** Programista opisuje, jak interfejs powinien wyglądać w danym stanie, a React zajmuje się efektywną aktualizacją DOM.\n*   **Wielokrotne użycie:** Komponenty mogą być używane w różnych miejscach aplikacji, co przyspiesza rozwój i poprawia spójność kodu.\n*   **Wydajność:** Dzięki mechanizmowi Virtual DOM, renderowanie i aktualizacje są szybkie.\n*   **Ekosystem:** React posiada jeden z największych i najbardziej dojrzałych ekosystemów w świecie front-endu (np. React Router, Redux/Zustand do zarządzania stanem, narzędzia deweloperskie).\n\n**Dodatkowy fakt:** Chociaż React jest pierwotnie biblioteką front-endową, dzięki **React Native** (oddzielny projekt) można używać tej samej deklaratywnej składni i logiki do tworzenia natywnych aplikacji mobilnych na iOS i Androida.', False, 'None')"
Co to jest CI/CD?,"(""Akronim **CI/CD** odnosi się do zestawu praktyk w inżynierii oprogramowania mających na celu automatyzację, przyspieszenie i poprawę jakości procesu dostarczania oprogramowania.\n\n### Rozwinięcie i Definicja\n\n| Akronim | Pełna Nazwa | Definicja |\n| :--- | :--- | :--- |\n| **CI** | **Ciągła Integracja (Continuous Integration)** | Jest to praktyka, w której programiści regularnie (wiele razy dziennie) integrują swoje zmiany kodu w głównym repozytorium. Każda integracja jest natychmiast automatycznie weryfikowana przez kompilacje i zautomatyzowane testy. |\n| **CD** | **Ciągłe Dostarczanie (Continuous Delivery)** / **Ciągłe Wdrażanie (Continuous Deployment)** | Obejmuje automatyzację całego procesu po CI. |\n\n**Ciągłe Dostarczanie (Continuous Delivery - CD)**: Kod jest gotowy do wdrożenia po pomyślnym przejściu wszystkich testów i jest przechowywany w repozytorium artefaktów. Wdrożenie do produkcji wymaga jednak **manualnej** akceptacji.\n\n**Ciągłe Wdrażanie (Continuous Deployment - CD)**: Jest to rozszerzenie Continuous Delivery, gdzie *każda* zmiana kodu, która pomyślnie przejdzie wszystkie etapy pipeline'u (w tym testy akceptacyjne), jest **automatycznie** wdrażana do środowiska produkcyjnego, bez interwencji człowieka.\n\n### Korzyści Wdrożenia CI/CD\n\nWdrożenie w pełni zautomatyzowanego pipeline’u CI/CD przynosi znaczące korzyści:\n\n1.  **Szybszy Czas Wprowadzenia na Rynek (Time-to-Market):** Automatyzacja minimalizuje opóźnienia i pozwala na częste, małe wydania.\n2.  **Mniej Błędów w Produkcji:** Wczesne i częste testowanie w CI szybko wykrywa błędy integracji i regresje, zanim trafią do dalszych etapów.\n3.  **Łatwiejsza Izolacja Błędów:** Ponieważ zmiany są małe i wdrażane często, łatwo jest określić, który konkretny commit spowodował problem.\n4.  **Zwiększona Jakość i Stabilność:** Automatyczne testowanie (jednostkowe, integracyjne, wydajnościowe) zapewnia wyższą jakość produktu.\n\n**Fakt dodatkowy:** Typowy pipeline CI/CD jest realizowany za pomocą narzędzi orkiestracji, takich jak **Jenkins, GitLab CI, GitHub Actions** czy **Azure DevOps**, które zarządzają kolejnymi krokami (kompilacja, testowanie, budowanie obrazów Docker, wdrożenie)."", False, 'None')"
Czym jest typowanie statyczne?,"('**Klucz główny (Primary Key)** to kolumna (lub zestaw kolumn) w relacyjnej bazie danych, która jednoznacznie identyfikuje każdy wiersz (rekord) w tabeli. Jest to fundamentalny element zapewniający integralność danych.\n\n### Kluczowe Cechy (Wymagania)\n\nAby kolumna mogła funkcjonować jako klucz główny, musi spełniać dwa kluczowe ograniczenia (constraints):\n\n1.  **Unikatowość (Uniqueness):** Wartość klucza głównego musi być unikalna w każdym wierszu tabeli. Nie mogą istnieć dwa rekordy z tą samą wartością klucza.\n2.  **Niepustość (NOT NULL):** Wartość klucza głównego nie może być pusta (NULL). Musi mieć zawsze przypisaną wartość.\n\n### Cel Stosowania Klucza Głównego\n\nGłównym celem stosowania klucza głównego jest:\n\n*   **Identyfikacja:** Zapewnienie szybkiego i jednoznacznego sposobu odwoływania się do pojedynczego rekordu.\n*   **Integralność Encji:** Utrzymanie spójności danych poprzez wymuszenie unikalności i niepustości.\n*   **Wydajność:** Klucze główne są automatycznie indeksowane, co przyspiesza operacje wyszukiwania i odzyskiwania danych.\n\n### Relacja Klucz Główny (Primary Key) a Klucz Obcy (Foreign Key)\n\nKlucz obcy to mechanizm stosowany do ustanawiania i wymuszania relacji między dwiema tabelami.\n\n*   **Klucz Główny (PK):** Definiuje rekord unikalnie w **tabeli źródłowej (tabeli rodzica)**.\n*   **Klucz Obcy (FK):** Jest to kolumna w **tabeli docelowej (tabeli dziecka)**, która odwołuje się do klucza głównego innej tabeli.\n\nKlucz obcy zapewnia **Integralność Referencyjną**, gwarantując, że wartości w kolumnie FK w tabeli dziecka zawsze odpowiadają istniejącym wartościom PK w tabeli rodzica, zapobiegając tym samym „wiszącym” rekordom.\n\n**Fakt dodatkowy:** Jeśli klucz główny składa się z więcej niż jednej kolumny, nazywany jest **kluczem złożonym (Composite Key)**. Wszystkie kolumny w kluczu złożonym muszą być niepuste i ich *kombinacja* musi być unikalna w obrębie tabeli.', True, 'None')"
Co to jest CSS Grid?,"('**CSS Grid Layout** (Siatka CSS) to dwuwymiarowy system układu dla CSS, który umożliwia podział przestrzeni na wiersze i kolumny, ułatwiając projektowanie złożonych, strukturalnych układów interfejsu użytkownika (UI).\n\n### Różnica między Grid a Flexbox\n\nKluczowa różnica polega na wymiarowości:\n\n*   **Grid:** Jest systemem **dwuwymiarowym** (2D). Pozwala na jednoczesne zarządzanie układem w wierszach i kolumnach, idealnie nadając się do tworzenia układu całej strony.\n*   **Flexbox:** Jest systemem **jednowymiarowym** (1D). Służy do rozmieszczania elementów wzdłuż jednej osi (poziomej lub pionowej) i jest lepszy do dystrybucji, wyrównania i sortowania małych komponentów wewnątrz większego kontenera.\n\n**Fakt dodatkowy:** Chociaż są różne, Flexbox i Grid nie są wykluczające — często stosuje się je razem (Grid do makro-układu, Flexbox do mikro-układu wewnątrz komórek Grid).\n\n### Kluczowe Elementy\n\nW Grid Layout kontrola nad układem odbywa się poprzez definicję kontenera siatki (`display: grid`) i jej zawartości:\n\n1.  **Definicja Wierszy i Kolumn:**\n    *   `grid-template-columns`: Definiuje liczbę i rozmiar kolumn.\n    *   `grid-template-rows`: Definiuje liczbę i rozmiar wierszy.\n    *   W definicjach tych często używa się jednostki `fr` (fraction), która reprezentuje dostępną przestrzeń w kontenerze, umożliwiając responsywne skalowanie.\n2.  **Umieszczanie Elementów:**\n    *   Elementy potomne (Grid Items) są umieszczane w siatce za pomocą właściwości: `grid-row-start`, `grid-row-end`, `grid-column-start`, `grid-column-end` (lub skróconych `grid-area`/`grid-column`/`grid-row`).\n\n### Scenariusze Zastosowania\n\nGrid jest najlepiej stosowany, gdy:\n\n1.  **Projektuje się główny układ strony (Layout):** Tworzenie stałych nagłówków, stopek, pasków bocznych i sekcji głównej.\n2.  **Wymagana jest kontrola w 2D:** Np. skomplikowane układy galerii, panele dashboardów, formularze wielokolumnowe.\n3.  **Wymagana jest zmiana kolejności na podstawie układu (a nie kodu HTML):** Możliwość umieszczenia elementów w dowolnej komórce siatki niezależnie od ich kolejności w kodzie źródłowym.', False, 'None')"
Wyjaśnij wzorzec Singleton.,"('Wzorzec projektowy **Singleton** (Jedynak) to wzorzec kreacyjny, który gwarantuje, że dana klasa ma **tylko jedną instancję** w całej aplikacji, a jednocześnie zapewnia globalny punkt dostępu do tej instancji.\n\n### Kluczowy Cel\n\nGłównym celem wzorca Singleton jest ścisła kontrola nad liczbą instancji klasy. Jest to szczególnie przydatne, gdy istnieje potrzeba, aby dokładnie jeden obiekt koordynował działania w systemie lub zarządzał zasobami globalnymi.\n\n### Sposób Implementacji\n\nTypowa implementacja Singletona wymaga spełnienia następujących kroków:\n\n1.  **Prywatny Konstruktor:** Ustawienie konstruktora klasy jako prywatnego, aby uniemożliwić tworzenie nowych instancji za pomocą operatora `new` z zewnątrz.\n2.  **Statyczna Zmienna Instancji:** Zdefiniowanie prywatnego, statycznego pola wewnątrz klasy, które będzie przechowywać jedyną instancję.\n3.  **Statyczna Metoda Fabrykująca:** Utworzenie publicznej, statycznej metody (często nazywanej `getInstance()` lub `instance()`), która:\n    *   Sprawdza, czy instancja już istnieje.\n    *   Jeśli nie istnieje, tworzy ją i przypisuje do statycznego pola.\n    *   Jeśli istnieje, zwraca istniejącą instancję.\n\n### Zalety i Wady Stosowania\n\n| Cecha | Zalety | Wady |\n| :--- | :--- | :--- |\n| **Kontrola Zasobów** | Idealny do zarządzania zasobami, które powinny być współdzielone globalnie (np. połączenia z bazą danych, konfiguracja, logery). | Maskuje złe praktyki projektowe; często staje się obiektem globalnym, co zwiększa silne sprzężenie (tight coupling) między modułami. |\n| **Lazy Loading** | Instancja jest tworzona tylko wtedy, gdy jest faktycznie potrzebna. | W środowiskach wielowątkowych wymaga dodatkowej synchronizacji (np. użycia słowa kluczowego `synchronized` w Javie), co może obniżyć wydajność. |\n| **Testowanie** | Prosty dostęp do instancji. | Utrudnia testowanie jednostkowe, ponieważ globalny stan Singletona jest trudny do izolowania, resetowania lub zastąpienia atrapami (mocks). |\n\n**Fakt dodatkowy:** Chociaż Singleton jest prosty w implementacji, w nowoczesnym programowaniu obiektowym często jest uważany za **antywzorzec** (anti-pattern). Lepszą, bardziej testowalną alternatywą w wielu przypadkach jest użycie technik **Wstrzykiwania Zależności (Dependency Injection)**.', False, 'None')"
Czym jest funkcja lambda?,"('**Funkcja lambda (wyrażenie lambda)** to mała, anonimowa funkcja zdefiniowana w pojedynczej linii kodu. Wiele języków programowania (w tym Python, JavaScript, Java) wspiera funkcje lambda jako zwięzły sposób tworzenia funkcji bez konieczności nadawania im formalnej nazwy.\n\n### Kluczowe Cechy\n\n1.  **Anonimowość (Brak Nazwy):** Funkcje lambda nie są definiowane za pomocą standardowego słowa kluczowego (`def` w Pythonie, `function` w JS), dlatego nie mają nazwy. Są to funkcje jednorazowego użytku.\n2.  **Kompaktowość:** Lambda jest zaprojektowana do wykonywania prostych, pojedynczych wyrażeń. Jest idealna jako argument przekazywany do funkcji wyższego rzędu (np. `map`, `filter`).\n\n### Typowa Skondensowana Składnia\n\nSkładnia funkcji lambda jest zazwyczaj skrócona i zorientowana na minimalizm.\n\n**W Pythonie:**\n```python\nlambda argumenty: wyrażenie_zwracające_wartość\n```\n*Przykład:* `dodaj = lambda x, y: x + y`\n\n**W JavaScript (Arrow Functions, które są formą lambda):**\n```javascript\n(argumenty) => wyrażenie_zwracające_wartość\n```\n*Przykład:* `dodaj = (x, y) => x + y`\n\n### Ograniczenia w Porównaniu do Zwykłych Funkcji\n\nFunkcje lambda mają celowe ograniczenia, które odróżniają je od standardowych funkcji:\n\n1.  **Jedno Wyrażenie:** Funkcja lambda może zawierać tylko jedno wyrażenie. Wartość tego wyrażenia jest automatycznie zwracana. Nie można w niej umieszczać wielu instrukcji (np. pętli, warunków wieloliniowych, przypisań).\n2.  **Brak Dokumentacji:** Z powodu ich zwięzłej natury, lambda nie obsługuje pełnej dokumentacji (docstrings) ani adnotacji typów w takim stopniu jak funkcje nazwane.\n3.  **Brak Złożonej Logiki:** Są nieodpowiednie do implementowania złożonych operacji. Służą tylko do prostych transformacji lub predykatów.\n4.  **Brak Pełnej Kontroli:** Nie mogą bezpośrednio zawierać słowa kluczowego `return` (jest ono dorozumiane).\n\n**Dodatkowy fakt:** Funkcje lambda są ściśle powiązane z paradygmatem **programowania funkcyjnego**, w którym funkcje są traktowane jako obiekty pierwszej klasy i mogą być przekazywane jako argumenty lub zwracane jako wyniki innych funkcji.', False, 'None')"
Co to jest JSON?,"('**JSON (JavaScript Object Notation)** to lekki format wymiany danych, który jest łatwy do odczytania dla ludzi i łatwy do parsowania oraz generowania przez maszyny. Pomimo nazwy, jest to format **niezależny od języka**, chociaż jego składnia wywodzi się z JavaScriptu.\n\n### Główny Cel\n\nGłównym celem JSON jest służyć jako uniwersalny sposób przesyłania strukturalnych danych między różnymi systemami komputerowymi. Jest to obecnie dominujący format używany w komunikacji typu klient-serwer, zwłaszcza w kontekście **interfejsów API RESTful** oraz nowoczesnych aplikacji webowych.\n\n### Podstawowe Struktury Danych\n\nJSON jest zbudowany wyłącznie z dwóch uniwersalnych struktur danych:\n\n1.  **Obiekt (Object):** Reprezentowany przez nawiasy klamrowe `{}`. Jest to nieuporządkowany zbiór par **nazwa/wartość** (klucz/wartość). Nazwy (klucze) muszą być ciągami znaków ujętymi w cudzysłów.\n    *   *Przykład:* `{""imie"": ""Anna"", ""wiek"": 30}`\n2.  **Tablica (Array):** Reprezentowana przez nawiasy kwadratowe `[]`. Jest to uporządkowana lista wartości. Wartości w tablicy mogą być dowolnego typu (string, numer, inny obiekt, inna tablica).\n    *   *Przykład:* `[""jabłko"", ""banan"", ""pomarańcza""]`\n\nJSON obsługuje również następujące typy wartości pierwotnych: ciągi znaków (string), liczby (number), logiczne (boolean: `true`, `false`) oraz `null`.\n\n### Zalety w Kontekście Komunikacji Sieciowej\n\n1.  **Czytelność dla Człowieka:** Składnia jest prosta i intuicyjna.\n2.  **Lekkość:** JSON jest znacznie krótszy i mniej „gadatliwy” (verbose) niż jego historyczny konkurent, XML, co redukuje rozmiar przesyłanych danych.\n3.  **Wsparcie Językowe:** Ze względu na jego pochodzenie, jest natywnie wspierany w JavaScript (bezpośrednie mapowanie na obiekty i tablice). Ponadto, niemal każdy współczesny język programowania posiada wbudowane lub łatwo dostępne narzędzia do parsowania JSON.\n4.  **Szybkość Parsowania:** Maszyny mogą go szybko przetwarzać, co jest kluczowe dla szybkich połączeń API.\n\n**Fakt dodatkowy:** Chociaż składnia JSON jest podzbiorem składni JavaScript, standard JSON nie pozwala na przechowywanie funkcji, dat jako typów natywnych (są one przechowywane jako ciągi znaków) ani komentarzy.', False, 'None')"
Czym jest wskaźnik (pointer) w C++?,"('**Wskaźnik (pointer)** w C++ to zmienna, która przechowuje **adres pamięci** innej zmiennej. Zamiast przechowywać dane bezpośrednio, wskaźnik przechowuje informację o lokalizacji, gdzie te dane się znajdują.\n\n### Kluczowa Funkcja\n\nKluczową funkcją wskaźnika jest umożliwienie **pośredniego dostępu** do danych oraz zarządzanie pamięcią. Wskaźniki są niezbędne do:\n\n1.  Dynamicznego przydzielania pamięci na stercie (Heap) za pomocą `new` i zwalniania za pomocą `delete`.\n2.  Efektywnego przekazywania dużych obiektów do funkcji bez kopiowania całej zawartości.\n\n### Podstawowa Składnia Operacji\n\nW C++ używa się dwóch głównych operatorów związanych ze wskaźnikami:\n\n| Operator | Nazwa operacji | Działanie | Przykład użycia |\n| :--- | :--- | :--- | :--- |\n| **`&`** | **Pobranie adresu (Address-of Operator)** | Zwraca adres pamięci zmiennej. | `int *wskaznik = &zmienna;` |\n| **`*`** | **Dereferencja (Dereference Operator)** | Odwołuje się do wartości przechowywanej pod adresem, na który wskazuje wskaźnik. | `int wartosc = *wskaznik;` |\n\n**Deklaracja:** Aby zadeklarować wskaźnik, używa się symbolu `*`: `int *ptr_liczba;` (deklaruje wskaźnik, który może wskazywać na zmienną typu `int`).\n\n### Typowe Scenariusze Zastosowania\n\nWskaźniki są fundamentalne w programowaniu systemowym i niskopoziomowym:\n\n1.  **Zarządzanie Pamięcią Dynamiczną:** Przydzielanie pamięci sterty dla struktur danych o nieznanym z góry rozmiarze (np. listy połączone, drzewa).\n2.  **Tablice i Arytmetyka Wskaźników:** Wskaźniki są ściśle powiązane z tablicami (nazwa tablicy często jest wskaźnikiem na jej pierwszy element), umożliwiając efektywną nawigację.\n3.  **Implementacja Struktur Danych:** Budowanie złożonych struktur danych (grafy, drzewa, listy) wymaga użycia wskaźników do łączenia węzłów.\n4.  **Współpraca z Interfejsami Systemowymi:** Operacje na plikach, pamięci współdzielonej czy bezpośredni dostęp do sprzętu (w kodzie niskopoziomowym).\n\n**Fakt dodatkowy:** Chociaż wskaźniki surowe (`raw pointers`) dają dużą kontrolę, są głównym źródłem błędów w C++ (wycieki pamięci, zawieszające wskaźniki). W nowoczesnym C++ zaleca się używanie **inteligentnych wskaźników (smart pointers)**, takich jak `std::unique_ptr` i `std::shared_ptr`, które automatyzują proces zwalniania pamięci, minimalizując ryzyko wycieków.', False, 'None')"
